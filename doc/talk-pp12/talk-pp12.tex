%========================================================================
% UNCOMMENT TO PRINT
%========================================================================

  \newcommand{\enhance}[1]{}
  \newcommand{\enhancebf}[2]{\textbf{#2}}
  \newcommand{\enhanceus}[1]{\color{blue}}
  \newcommand{\enhancenewus}[1]{\color{magenta}}
  \newcommand{\enhancethem}[1]{\color{red}}
 \newcommand{\ENHANCE}[1]{
  \temporal<#1>{\color{lightgray}}{\color{black}}{\color{gray}}}

%========================================================================
% UNCOMMENT FOR TALK:
%========================================================================

%\newcommand{\enhance}[1]{\temporal<#1>{\color{lightgray}}{\color{black}}{\color{black}}}
% \newcommand{\enhancebf}[2]{\enhance{#1}\textbf{#2}}
% \newcommand{\enhanceus}[1]{\temporal<#1>{\color{lightgray}}{\color{blue}}{\color{blue}}}
% \newcommand{\enhancenewus}[1]{\temporal<#1>{\color{lightgray}}{\color{magenta}}{\color{magenta}}}
% \newcommand{\enhancethem}[1]{\temporal<#1>{\color{lightgray}}{\color{red}}{\color{red}}}
%\newcommand{\ENHANCE}[1]{
% \temporal<#1>{\color{lightgray}}{\color{black}}{\color{black}}}
%========================================================================

\includeonly{
  slide-amr,
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%    This LaTeX source was automatically generated by outlinebeamer.pl     %
%                                                                          %
%   Remember that most changes should be made to the outline source file   %
% changes to this file will be overwritten when the file gets regenerated  %
%                                                                          %
%                  outlinebeamer - Outline Beamer Class Presentation Maker %
%                                    http://outlinebeamer.sourceforge.net/ %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\documentclass{beamer}


\documentclass{beamer}

\usetheme{Copenhagen}
\usecolortheme{default}

\newcommand{\Code}[1]{\textsf{#1}}
\newcommand{\cello}{\textsf{Cello}}
\newcommand{\enzo}{\textsf{Enzo}}
\newcommand{\enzop}{\textsf{Enzo-P}}
\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\us}[1]{\color{blue}{#1}}
\newcommand{\them}[1]{\color{red}{#1}}
\newcommand{\newus}[1]{\color{magenta}{#1}}
\newcommand{\good}{\textcolor{green}{\smiley}}
\newcommand{\bad}{\textcolor{red}{\frownie}}
\newcommand{\colorcode}[1]{\textcolor{blue}{\code{#1}}}
\newcommand{\itemnum}[1]{\item<#1>}

\author{James Bordner}
\date{\today}

%======================================================================
% BEGIN
%======================================================================

\begin{document}

%======================================================================
% TITLE
%======================================================================

\frame{
\centerline{\includegraphics[width=3.5in]{Enzo-P-logo-full-2.png}}
\centerline{\cello: An Extremely Scalable Adaptive Mesh Refinement Framework}

\centerline{James Bordner}
\centerline{San Diego Supercomputer Center}
\centerline{University of California, San Diego} \ \\
\footnotesize
\centerline{15th SIAM Conference on Parallel Processing for Scientific Computing}
\centerline{\today} \ \\
}

%========================================================================
%
% ABSTRACT

 We present {\tt Cello}, a highly-scalable parallel AMR framework currently
 under development.  Its octree-like distributed data structure
 includes enhancements to scalability in terms of hierarchy size and
 depth, and supports both particle and uniform mesh data.  The
 message-driven parallel programming system used, {\tt CHARM++}, enables
 overlapping communication and computation, and provides dynamic
 load-balancing and checkpoint-restart capabilities.  Despite being
 developed and tested using a specific cosmology
 application, {\tt Cello} is a general AMR framework usable with other
 applications.

% and efficient will  CHARM++Parallelization will include CHARM++, 
% dynamic load balancing and 
% features of Cello include a modified octree-like
% data structure supporting both uniform mesh and particle data,

%  Cello will support


% ism, pushes the limit on 
% Features include building extreme scalability at the outset, including
% processor count, hierarchy size, and hierarchy depth.  Cello will support
% both ``field'' and ``particle'' data.  Cello is built on CHARM++, with
% MPI as a compile-time option.  Cello's driving application is Enzo,
% but Cello is designed as a standalone framework.  We discuss Cello's
% planned capabilities, data structure features, parallelism approach,
% current status, and preliminary results.

The driving application area, cosmology and astrophysics, requires extreme
AMR depth
to the limit in reso

AMR
framework
extreme scaling
The target driving application, Enzo, is a community cosmology and astrophysics
code, which continually pushes the limits of existingused for cosmological structure formation, galaxy and star formation, and
turbulence.
  and extreme hierarchy depths for galaxy and star formation.
fully distributed data structures
several refinement octree enhancements, improving
hierarchy scalability both in number of grid patches
and hierarchy depth.

uniform grid patches and particle data,
process virtualization through CHARM++.
Support for threaded or GPGPU-based solvers





  rapid refinement gradients


%
%========================================================================

%========================================================================
% SECTION PAGES [ COMMENT FOR PRINT ]
%========================================================================
% \frame{\footnotesize
% \tableofcontents
% }
%  \AtBeginSection[]
% {
% \begin{frame}<beamer>
% \footnotesize
%    \tableofcontents[currentsection]
% \end{frame}
% }
%========================================================================


\end{document}

% --------------------------------------------------
%
% INTRODUCTION: ENZO-P / CELLO
%    
% --------------------------------------------------
%
% PARAMETERS
%
%   * Problem definition
%     - Enzo:  problem definition in code ("problem_type") and parameter file
%     - Enzo-P problem definition in parameter file
%     - requires much more flexible parameter files
%       - hierarchical organization
%       - more types 
%       - more difficult to implement
%       - flex for lexical analysis, bison for parsing
%         - generates C-code, which is thoroughly tested
%   * Parameter files
%     * parameters organized into "groups" and "subgroups"
%     * parameter types much more flexible than Enzo
%     * Enzo-P developers can trivially add new parameters:
%        parameters->set_current_group("Physics");
%        bool physics_on = parameters->("enable_physics",true);
%   * Parameter file example: Implosion problem
%   * Parameter file example: Collapse test
%   * Parameter file data types
%
%     - integer
%     - scalar
%     - logical
%     - string
%     - list
%     - scalar expression, 
%     - logical expression
%   parameters: hierarchical
%   parameters: expressive data types
%   parameters: easy to add new parameters: just use [API example]
%   parameters: compare parameter files with Enzo [implosion]
%   - initial conditions
%     - scalar expression "if-else" list
%     - input file
%     - user "initial" method
%
% --------------------------------------------------
%
% CODE DESIGN
%
%   Components
%   Component summary
%   - organized into "component" subdirectories
%   - e.g. Mesh, Field, Particles, Parameters
%   - Enzo-P code goes in User component
%   - data structures only manipulated directly from own class
%     - standard iterator functions for traversing complicated data structures
%       - [ hypre-solve code ]
%   
%
%
% --------------------------------------------------
% 
% AMR COMPONENT
%
%  * AMR variants
%    - "Structured" AMR
%      - e.g.~Enzo, Chombo, SAMRAI
%    - "Octree-based" AMR
%      - e.g.~Flash, ...
%  * Scalable AMR is an unsolved problem
%      - SAMR has scalablity issues
%        - gridding algorithm has scaling issues
%        - parent-child communication 
%        - scheduling/balancing variable-sized tasks
%      - Octree-AMR has scalability issues
%         - fixed-size patches inefficient for "shallow" AMR
%         - refining a single point involves entire root-level patch
%         - octree refinement inefficient for "deep" AMR
%     - Enzo-P: modified "octree-based" AMR
%       - similar to e.g. Flash, but with several (currently proprietary) enhancements
%       - improved scalability:
%         - fully distributed metadata
%         - only data transfer is between adjacent grid patches
%           - no parent-child
%       - improved performance
%         - patches subdivided into "blocks" (cache-friendly)
%         - unigrid is single AMR patch of blocks
%         - a timestep on a block is a single parallel task
%       - enhancements for "wide" problems (large regions at same level)
%         - Basic octree with fixed-sized blocks refines too much
%           - Flash patch count proportional to refinement area * $8^{level}$
%           - Enzo-P patch count proportional to refinement-change area $8^{level}$
%           - [figure]
%           - Enzo patch count good, but smaller patches at finer levels
%       - enhancements for "deep" problems (many refinement levels)
%         - octree refinment not "targeted": single point involves entire domain
%         - we will allow refinement by 4 and possibly 8
%            - still maintain smooth level jumps by 2 everywhere
%         - will address integer index range issues
%         - will address floating point positional precision issues
%       - reduced operations for physics modules compared to SAMR
%         - cubical typically small blocks
%         - limited inter-block configurations [ figure ]
%   * Cello AMR philosophy
%     - "AMR hierarchy" defines changes in resolution
%     - "AMR patch" defines areas of uniform resolution
%     - hierarchy size should be proportional to "amount" of resolution change
%       - not true of standard octree AMR (Flash) due to fixed-size patches
%       - not strictly true of Enzo AMR due to unigrid level (hierarchy = O(P^2)[?])
%     - Cello adds a new "level" to AMR
%       - "AMR block" defines task size
%       - typically small, e.g. $4^3$ to $8^3$
%       - a patch is composed of one or more blocks
%       - unigrid problem is single patch
%       - decouples "uniform resolution" requirements from "parallel task size"
%     - AMR 
%   AMR:        totally new AMR approach: generalization of octrees--rationale
%   AMR:        additional level of refinement: patches + blocks
%   AMR:        new [currently proprietary] enhancement for "large, shallow" AMR
%   AMR:        new [currently proprietary] enhancement for "deep, targeted" AMR
%   AMR:        no level jumps, symmetric refinement for symmetric problems
%   AMR:        ghost zones optionally allocated only when needed
%   AMR:        octree node memory footprint is light: 3 pointers (24 bytes) per patch
%   AMR:        optional fully distributed AMR hierarchy
%   scalability: Only adjacent block communication--no parent/child communication
%   scalability: Optional fully-distributed hierarchy (local patch + neighboring "ghost" patches)
%   performance: block sizes can be fixed (or at least quantized, e.g. $4^3$ $8^3$ or $16^3$), reducing memory fragmentation, improving cache utilization
%   performance: AMR enhancements will greatly reduce metadata
%   problem support: Deep: integer range and floating point precision
%   problem support: Deep: "level windows" to reduce memory usage
%   problem support: AMR enhancements for targeted refinement by 4 or 8 ["backfill" to maintain level jumps at most 2]
%
% --------------------------------------------------
%
% --------------------------------------------------
%
% USER COMPONENT
%
%  - Cello is designed to be a general-purpose "extreme AMR" framework
%  - "User" component is designed to hold application-specific
%   Enzo-P:     All Enzo physics code in User component
%   Enzo-P:     Includes methods (block advance, face update), timestep determination, control (ala EvolveLevel)
%      UserMethod:     basic method, initialization, analysis functions
%      UserCorrect:  "flux-correction" type operations at level interface boundaries
%      UserBoundary:  user-defined boundary conditions
%      UserTimestep:  user-defined timestep control (ala EvolveLevel)
%      UserRefinement user-defined refinement criteria
%      UserBalance    user-defined load balancing
%      UserSchedule   user-defined task scheduling
%      User????       other functions required?

% --------------------------------------------------
%
% MEMORY COMPONENT
%
%  - optionally fill memory with NaN after allocate
%    - help catch access of uninitialized data
%  - optionally fill memory with Nan before deallocate
%    - help catch access of unallocated data
%  - optionally track current / high memory per process
%  - optionally warn when memory threshold reached
%  - fixed (quantized) field (particle) block sizes
%    - should help reduce memory fragmentation
%  - can wrap other memory management libraries
%
% --------------------------------------------------
%
% PORTAL COMPONENT
%
%  * interact with external utilities
%    - yt, jacques, etc.
%  - inter-application communication using Parameters-like API
%    - probably XML
%    - read commands to retrieve data
%    - write commands to control simulation
%  * Example uses
%    - control
%      - modify simulation parameters as it progresses
%      - maintain log so results can be reproduced
%    - locate
%      - dynamically look for and track features
%    - analyse
%    - visualize
%      - e.g. contral a dynamic camera position, direction, frequency sensitivity, etc.
%    - performance
%      - find performance problems
%      - dynamically modify parameters to correct
%
%  * user-driven dynamic analysis
%    - more efficient than a posteriori analysis
%      - no large disk dumps
%    - more flexible than inline analysis
%      - discover and analyse features at run time
%      - all data available
%    - can dynamically change what data to store for later analysis
%      - useful if analysis would otherwise slow the computation
%
% --------------------------------------------------
%
% SOFTWARE ENGINEERING AND QUALITY CONTROL
%
% - prototyping
%   - proof-of-concept
%   - iron out design issues
%   - proven technique
% - testing
%   - unit testing integrated with code build (scons not make)
%   - integration tests how classes/components interact
%   - system tests entire application
%   - regression testing
%   - test for previously-found bugs to prevent their reappearance
% - code reviewing
%   - goal: every line of code is proof-read
%   - proven effective
% - combining techniques more effective than individual
%   - computers tend to find different kinds of bugs than people

% --------------------------------------------------
%
% OUTPUT
%
%   Output:     Currently HDF5 and IFrit files supported
%   Output:     Different output 'types', restart, data, visualization, analysis, etc.
%
% --------------------------------------------------
%
% ERROR
%
%   Fault-tolerant design
% --------------------------------------------------
%
% PARALLELISM
%
%   parallel:   hierarchical: distributed-memory, shared-memory [GPU level]
%   parallel:   any level can be parallelized with different parallel technology (MPI,UPC,etc.)
%   parallel:   load balancing approach specified in parameter file, may be user-defined.  Initially space-filling curve, ultimately hierarchical diffusion
%   parallel:   fully distributed data structures (no / fixed global metadata)
%   Schedule, Balance, Task [ uml ]
%  
%     - dynamic parallel task creation / scheduling / migration
%       [ enzo is more static ]
%       [ remove unnecessary synchronization, e.g. between levels ]
%
% --------------------------------------------------
%
% FEEDBACK
%
%   % Limitations
%   * Enzo-P limitations
%     - cubical domains
%       - may be able to bypass
%         - use subset of domain
%         - set boundary conditions at internal positions
%         - need to refine along physical boundary for accuracy
%         - mask-out unused patches / blocks
%
% --------------------------------------------------
%
% CURRENT STATUS AND ROADMAP
%
% Initial Unigrid Release "Soon"
%
%   * Pre-release
%     - unigrid only
%     - PPM hydro only
%     - MPI only
%     - Why use it?
%       - flexible parameter files
%       - hopefully faster and more scalable
%         - adjustable field ordering, alignment, padding
%         - multiple data blocks per process (more cache friendly)
%         - treats unigrid as unigrid, not as AMR
%       - I need feedback
%
% Roadmap
%
%   + gravity (FFT(Harkness) or multigrid)
%   + PPML (with Kritsuk and Ustyugov
%   + AMR (after development and paper)
%
%   roadmap:    available now: Fields, Parameters, serial unigrid PPM
%   roadmap:    available imminently: parallel unigrid MPI-[12] PPM, PPML, gravity (FFT or MG)
%   roadmap:    available next: basic AMR (octree), local physics 
%   roadmap:    longer-term: particles, cosmology, enhanced AMR
%   roadmap:    papers: AMR enhancements
%   roadmap:    
%   development: extensive unit tests built into build
%   development: scons instead of make: advantages [disadvanteges]
%   development: currently subversion is sufficient--no branching
%   development: "physics" part separate from parallelism and data structures
%   problem support: Deep: integer range and floating point precision
%   problem support: Deep: "level windows" to reduce memory usage
%   problem support: AMR enhancements for targeted refinement by 4 or 8 ["backfill" to maintain level jumps at most 2]
%   feedback:  parameters
%   feedback:  functionality
%   feedback:  
%
% SLIDES
%
% * Enzo-P / Cello summary
%   
% * Why Enzo-P?
%    
% --------------------------------------------------
%
% CONCLUSIONS
%
%
% --------------------------------------------------
