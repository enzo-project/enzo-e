([NotesComponentError Error] < [NotesComponents index] > [NotesComponentMemory Memory])

= `Field` Component =

[[TOC]]

A `Field` represents a discretized scalar field.  A `Field` is typically discretized on a `Mesh`, but can be accessed at the `Array` or a `Block` levels as well.  In addition to the array of elements, a `Field` includes an identifier for the field, the location of the field values with respect to computational cells (cell centered, face-centered, etc.), the index into the `Block` or `Array` of the field, optional minimum or maximum allowed values, units, and user-defined tags.

A set of `Field`s defined on a `Block`, along with groups of `Particles` associated with the block, are the main input to (and output from) `Method`s.  `Method`s have access to the `Field`'s values, size, cell position, units, tags, limits, etc. 

Actual `Field` objects are stored in the `Mesh` `Patch` object.  `Patch` objects also contain associated `Particle` objects, and a `Box` object defining the `Patch`'s extents and position.

== Enzo Fields ==

Below is a list of fields used in Enzo (week-of-code at 2010-04-14), and proposed names in Cello:

|| 0 ||  `Density`         ||  `density` ||
|| 1 ||  `TotalEnergy`     || `energy_total` ||
|| 2 ||  `InternalEnergy`  || `energy_internal` ||
|| 3 ||  `Pressure`        || `pressure` ||
|| 4 ||  `Velocity1`       || `velocity_x` ||
|| 5 ||  `Velocity2`       || `velocity_y` ||
|| 6 ||  `Velocity3`       || `velocity_z` ||
|| 7 ||  `ElectronDensity` || `density_electron` ||
|| 8 ||  `HIDensity`       ||  `density_HI` ||
|| 9 ||  `HIIDensity`      || `density_HII` ||
|| 10 ||  `HeIDensity`      || `density_HeI` ||
|| 11 ||  `HeIIDensity`     || `density_HeII` ||
|| 12 ||  `HeIIIDensity`    || `density_HeIII` ||
|| 13 ||  `HMDensity`       || `density_HM` ||
|| 14 ||  `H2IDensity`      || `density_H2I` ||
|| 15 ||  `H2IIDensity`     || `density_H2II` ||
|| 16 ||  `DIDensity`       || `density_DI` ||
|| 17 ||  `DIIDensity`      || `density_DII` ||
|| 18 ||  `HDIDensity`      || `density_HDI` ||
|| 19 ||  `SNColour`        || `color_SN` ||
|| 20 ||  `Metallicity`     || `metallicity` ||
|| 21 ||  `ExtraType0`      || `extra_0` ||
|| 22 ||  `ExtraType1`      || `extra_1` ||
|| 23 ||  `kphHI`           || `kph_HI` ||
|| 24 ||  `PhotoGamma`      || `gamma_photo` ||
|| 25 ||  `kphHeI`          || `kph_HeI` ||
|| 26 ||  `gammaHeI`        || `gamma_HeI` ||
|| 27 ||  `kphHeII`         || `kph_HeII` ||
|| 28 ||  `gammaHeII`       || `gamma_HeII` ||
|| 29 ||  `kdissH2I`        || `kdiss_H2I` ||
|| 30 ||  `GravPotential`   || `potential_gravity` ''[relation to 44?]'' ||
|| 31 ||  `Acceleration0`   || `acceleration_x` ||
|| 32 ||  `Acceleration1`   || `acceleration_y` ||
|| 33 ||  `Acceleration2`   || `acceleration_z` ||
|| 34 ||  `RadPressure0`    || `pressure_radiation_x` ||
|| 35 ||  `RadPressure1`    || `pressure_radiation_y` ||
|| 36 ||  `RadPressure2`    || `pressure_radiation_z` ||
|| 37 ||  `gParticlePosition`     || `particle_position` ''[vector?]'' ||
|| 38 ||  `gParticleVelocity`     || `particle_velocity` ''[vector?]'' ||
|| 39 ||  `gParticleMass`         || `particle_mass` ||
|| 40 ||  `gParticleAcceleration` || `particle_acceleration` ''[vector?]'' ||
|| 41 ||  `gParticleNumber`       || `particle_number` ||
|| 42 ||  `gParticleType`         || `particle_type` ||
|| 43 ||  `gParticleAttribute`    || `particle_attribute` ''[array?]'' ||
|| 44 ||  `gPotentialField`       || `potential` ''[relation to 30?]'' ||
|| 45 ||  `gAccelerationField`    || `gravity_acceleration ''[vector?]'' ||
|| 46 ||  `gGravitatingMassField` || `gravity_mass` ||
|| 47 ||  `gFlaggingField`        || `gravity_flagging` ||
|| 48 || `gVelocity`             || `gravity_vector` ''[vector?]'' ||
|| 49 ||  `Bfield1`               || `B_x` ||
|| 50 ||  `Bfield2`               || `B_y` ||
|| 51 ||  `Bfield3`               || `B_z` ||
|| 52 ||  `PhiField`              || `phi` ||
|| 53 ||  `Phi_pField`            || `phi_p` ||
|| 54 ||  `DebugField`            || `debug` ||
|| 55 ||  `DrivingField1`         || `driving_x` ||
|| 56 ||  `DrivingField2`         || `driving_y` ||
|| 57 ||  `DrivingField3`         || `driving_z` ||
|| 58 ||  `AccelerationField1`         || ''[redundant? (31)]'' ||
|| 59 ||  `AccelerationField2`         || ''[redundant? (32)]'' ||
|| 60 ||  `AccelerationField3`         || ''[redundant? (33)]'' ||
|| 61 ||  `Galaxy1Colour`          || `color_galaxy_1` ||
|| 62 ||  `Galaxy2Colour`          || `color_galaxy_2` ||
|| 63 ||  `Mach`            || `mach` ||
|| 64 ||  `PreShockTemperature` || `temperature_preshock` ||
|| 65 ||  `PreShockDensity` || `density_preshock` ||
|| 66 ||  `CRDensity`       || `density_CR` ||
|| 67 ||  `CIDensity`       || `density_CI` ||
|| 68 ||  `CIIDensity`      || `density_CII` ||
|| 69 ||  `OIDensity`       || `density_OI` ||
|| 70 ||  `OIIDensity`      || `density_OII` ||
|| 71 ||  `SiIDensity`      || `density_SiI` ||
|| 72 ||  `SiIIDensity`     || `density_SiII` ||
|| 73 ||  `SiIIIDensity`    || `density_SiIII` ||
|| 74 ||  `CHIDensity`      || `density_CHI` ||
|| 75 ||  `CH2IDensity`     || `density_CH2I` ||
|| 76 ||  `CH3IIDensity`    || `density_CH3II` ||
|| 77 ||  `C2IDensity`      || `density_C2I` ||
|| 78 ||  `COIDensity`      || `density_COI` ||
|| 79 ||  `HCOIIDensity`    || `density_HCOII` ||
|| 80 ||  `OHIDensity`      || `density_OHI` ||
|| 81 ||  `H2OIDensity`     || `density_H2OI` ||
|| 82 ||  `O2IDensity`      || `density_O2I` ||
|| 83 ||  `MBHColour`       || `color_MBH` ||
|| 84 ||  `ForbiddenRefinement` || `refine` ''[boolean]'' ||
|| 85 ||  `FieldUndefined`  || `unknown` ||



== `Field` supporting classes ==


=== `Field` class ===

=== Functions ===

=== Attributes ===

 ||  || name || String defining the field's name ||
 ||  || id || Integer handle identifying the `Field` (somewhat redundant with block_* attributes) ||
 ||  || dim || Dimension of the `Field` ||
 ||  || block_number  || Identify which `Block` contains the `Field` data ||
 ||  || block_offset || Identify where in the `Block` is the `Field` data ||
 ||  || position || cell position, defined as (0,0,0) <= (px,py,pz) <= (1,1,1).  (.5,.5,.5)=cell centered ||
 ||  || min || minimum allowed value for the `Field` ||
 ||  || max || maximum allowed value for the `Field` ||
 ||  || min_action || what should be done if `Field` goes below `min` (e.g. 1: set to min, 2: warning, 4: error, g: retry with smaller timestep, etc.) ||
 ||  || max_action || what should be done if `Field` goes above `max` ||
 ||  || precision || single, double, ...? ||


==== Usage ====

Issues:
 * What operations are the responsibility of `Field` versus `Array`, `Task`, `Patch`, etc.
    * see below: `Field` stores only global properties of field, not actual data
 * How to store global attributes (name, index, min, max, position, etc.) versus non-global (values)
    * Single global `Field` object for each field
    * `Field`s don't store actual `Array`s, `Patches` do--`Field` only stores `Array` index (id_).
{{{ 

@@@ UPDATE @@@

   // Create an MPI object (Parallel)

   Mpi *mpi = new Mpi(...);

   int na[] = {64,64,64};  // Array size
   int np[] = {8,8,8};     // Mpi processor topology

   // Create a Layout object for MPI-distributed Arrays

   Layout * layout = new LayoutMpi(*mpi, na, np);

   // Create Fields

   Field * field_density    = new Field(0,"density",...);
   Field * field_velocity_x = new Field(1,"velocity-x");
   Field * field_velocity_y = new Field(2,"velocity-y");
   Field * field_velocity_z = new Field(3,"velocity-z");

    // Create a list of all Fields

   ListField all_fields;

   all_fields.push_back(field_density);
   all_fields.push_back(field_velocity_x);
   all_fields.push_back(field_velocity_y);
   all_fields.push_back(field_velocity_z);

   // Create an iterator over blocks in the layout

   ItBlocks block_loop (*layout);

   // Array block storage (initialize in loop below)

   Scalar * array_density;
   Scalar * array_velocity_x;
   Scalar * array_velocity_y;
   Scalar * array_velocity_z;

   // Array block dimensions (initialize in loop below)

   int nd0,  nd1,  nd2;
   int nvx0, nvx1, nvx2;
   int nvy0, nvy1, nvy2;
   int nvz0, nvz1, nvz2;

   // Array block size (initialize in loop below)

   int n0,n1,n2;

   while (Block * block = block_loop++) {

      // Signal neighbors that ghost zones are required

      all_fields.ghosts_required(*block);

      // Get block size

      block->get_size (&nx,&n1,&n2);

      // Extract Field arrays and dimensions for the block

      field_density   ->get_array(&array_density,    &nd0,  &nd1,  &nd2);
      field_velocity_x->get_array(&array_velocity_x, &nvx0, &nvx1, &nvx2);
      field_velocity_y->get_array(&array_velocity_y, &nvy0, &nvy1, &nvy2);
      field_velocity_z->get_array(&array_velocity_z, &nvz0, &nvz1, &nvz2);

      method_ppm.apply (dt, n0,n1,n2,
                        array_density,nd0,nd1,nd2,
                        array_velocity_x,nvx0,nvx1,nvx2,
                        array_velocity_y,nvy0,nvy1,nvy2,
                        array_velocity_z,nvz0,nvz1,nvz2,
                        ...);

      // Signal neighboring blocks that updated ghost zone data is available

      all_fields.ghosts_available(*block);

   }

}}}
([NotesComponentError Error] < [NotesComponents index] > [NotesComponentMemory Memor])
