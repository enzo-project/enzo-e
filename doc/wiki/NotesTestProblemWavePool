= Wave Pool Test Problem =

[[TOC]]

== Enzo parameters ==

{{{

ProblemType            = 2       // Wave Pool                   
TopGridRank            = 1                                      
TopGridDimensions      = 100                                    
HydroMethod            = 0                                      
                                        

# Default values of unspecified parameters as initialized in WavePoolInitialize.C
#
#   WavePoolAngle      = 0
#   WavePoolDensity    = 1
#   WavePoolPressure   = 1
#   WavePoolVelocity1  = 0
#   WavePoolVelocity2  = 0
#   WavePoolVelocity3  = 0


WavePoolAmplitude      = 0.01    // linear amplitude in density 
WavePoolWavelength     = 0.1     // 1/10 of the box             
WavePoolNumberOfWaves  = 1                                      
WavePoolSubgridLeft    = 0.5     // start of subgrid            
WavePoolSubgridRight   = 0.75    // end of subgrid              

StopTime               = 1.0
dtDataDump             = 0.1

Gamma                  = 1.4
PPMDiffusionParameter  = 0

StaticHierarchy           = 0    // "static" hierarchy
MaximumRefinementLevel    = 0
RefineBy                  = 4    // refinement factor

tiny_number            = 1.0e-6  // fixes velocity slope problem

}}}

== Enzo code ==

{{{
int ExternalBoundary::SetWavePoolBoundary(FLOAT time)                           
{                                                                               
  /* declarations */                                                            
                                                                                
  int i, j, dim, index;                                                         
  int NumberOfZones[MAX_DIMENSION], Offset[MAX_DIMENSION];                      
  float Omega, Perturbation, deltime, distance, pos[MAX_DIMENSION];             
  float WaveDensity, WaveTotalEnergy, WavePressure, WaveVelocity;               
  float WaveAverageVelocity, WaveVelocity123[MAX_DIMENSION];                    
  const float TwoPi = 6.283185;                                                 
                                                                                
  /* Compute the velocity and time constant for the wave. */                    
                                                                                
  WaveAverageVelocity = sqrt(Gamma*WavePoolPressure/WavePoolDensity);           
  Omega               = TwoPi*WaveAverageVelocity/WavePoolWavelength;           
                                                                                
  /* Compute size of entire mesh. */                                            
                                                                                
  int size = 1;                                                                 
  for (dim = 0; dim < BoundaryRank; dim++)                                      
    size = size*BoundaryDimension[dim];                                         
                                                                                
  /* Find fields: density, total energy, velocity1-3. */                        
                                                                                
  int DensNum, GENum, Vel1Num, Vel2Num, Vel3Num, TENum;                         
  if (this->IdentifyPhysicalQuantities(DensNum, GENum, Vel1Num, Vel2Num,        
                                         Vel3Num, TENum) == FAIL) {             
    fprintf(stderr, "Error in IdentifyPhysicalQuantities.\n");                  
    return FAIL;                                                                
  }                                                                             
                                                                                
  /* set the appropriate BoundaryValues on the left side */                     
                                                                                
  for (dim = 0; dim < BoundaryRank; dim++)                                      
    if (BoundaryDimension[dim] != 1) {                                          
                                                                                
      /* If the BoundaryValue fields are missing, create them. */               
                                                                                
      for (int field = 0; field < NumberOfBaryonFields; field++)                
        if (BoundaryValue[field][dim][0] == NULL)                               
          BoundaryValue[field][dim][0] =                                        
            new float[size/BoundaryDimension[dim]];                             
                                                                                
      /* Compute quantities needed for boundary face loop (below). */           
                                                                                
      int dim1, dim2;                                                           
      dim1 = (dim == 0) ? 1 : 0;                                                
      dim2 = dim1 + 1;                                                          
      dim2 = (dim2 == dim) ? dim2+1 : dim2;                                     
      for (i = 0; i < 3; i++) {                                                 
        NumberOfZones[i] = max(BoundaryDimension[i] - 2*DEFAULT_GHOST_ZONES,1); 
        Offset[i]        = min(DEFAULT_GHOST_ZONES, BoundaryDimension[i]) - 1;  
      }                                                                         
      pos[dim] = 0.0;                                                           
                                                                                
      /* Loop over the boundary face. */                                        
                                                                                
      for (i = 0; i < BoundaryDimension[dim1]; i++)                             
        for (j = 0; j < BoundaryDimension[dim2]; j++) {                         
                                                                                
          /* Find the 3D vector from the corner to the current location. */     
                                                                                
          pos[dim1] = (float(i-Offset[dim1]))*                                  
            (DomainRightEdge[dim1]-DomainLeftEdge[dim1]) /                      
              float(NumberOfZones[dim1]);                                       
          pos[dim2] = (float(j-Offset[dim2]))*                                  
            (DomainRightEdge[dim2]-DomainLeftEdge[dim2]) /                      
              float(NumberOfZones[dim2]);                                       
                                                                                
          /* Compute the distance along the wave propogation vector             
             (cos(angle), sin(angle), 0). Convert to radians. */                

          distance = pos[0]*cos(WavePoolAngle*TwoPi/360.0) +
                     pos[1]*sin(WavePoolAngle*TwoPi/360.0); 
                                                            
          /* Find the difference between the current time and the time at
             which the wave will reach this point. */                    
                                                                         
          deltime = time - distance/WaveAverageVelocity;                 
                                                                         
          /* If this point is currently inside the wave-train, compute the
             appropriate density, velocity and energy. */                 
                                                                          
          if (deltime*WaveAverageVelocity <                               
              WavePoolWavelength*float(WavePoolNumberOfWaves) &&          
              deltime > 0.0) {                                            
            Perturbation    =  WavePoolAmplitude *                        
                               sin(Omega*deltime) / WavePoolDensity;      
            WaveDensity     =  WavePoolDensity  *    (1+Perturbation);    
            WavePressure    =  WavePoolPressure * POW(1+Perturbation, Gamma);
            WaveVelocity    =  WaveAverageVelocity *      Perturbation;      
            WaveTotalEnergy =  WavePressure/((Gamma-1)*WaveDensity);         
            if (HydroMethod != Zeus_Hydro)                                   
              WaveTotalEnergy += 0.5*WaveVelocity*WaveVelocity;              
            WaveVelocity123[0] = WaveVelocity*cos(WavePoolAngle*TwoPi/360.0);
            WaveVelocity123[1] = WaveVelocity*sin(WavePoolAngle*TwoPi/360.0);
            WaveVelocity123[2] = 0.0;                                        
          } else {                                                           

            /* If not, set the fields to their ambient values. */

            WaveDensity     = WavePoolDensity;
            WaveTotalEnergy = WavePoolPressure/((Gamma-1)*WavePoolDensity);
            WaveVelocity123[0] = 0.0;
            WaveVelocity123[1] = 0.0;
            WaveVelocity123[2] = 0.0;
          }

          /* Set the field values. */

          index = j*BoundaryDimension[dim1] + i;

          *(BoundaryValue[DensNum][dim][0] + index) = WaveDensity;
          *(BoundaryValue[TENum][dim][0]   + index) = WaveTotalEnergy;
          *(BoundaryValue[Vel1Num][dim][0] + index) = WaveVelocity123[0];
          if (BoundaryRank > 1)
            *(BoundaryValue[Vel2Num][dim][0] + index) = WaveVelocity123[1];
          if (BoundaryRank > 2)
            *(BoundaryValue[Vel3Num][dim][0] + index) = WaveVelocity123[2];

        } // end loop over boundary slice

    } // end loop over boundary directions
 return SUCCESS;

}


}}}

== Cello parameters ==

{{{

  # Define the domain to be the 1D interval from 0 to 1

  Domain { range = [0.0, 1.0] } 
                                
  # Define field properties with named groups 
                                
  Field pressure { floor = 1.0e-6 }
  Field density  { floor = 1.0e-6 }
                                   
  # Set global field parameters with unnamed group

  Field { interleave = [density, total_energy, internal_energy] }

  # The grid is a "unigrid" array of 100 cells parallelized using MPI
  # Other types are patch_amr and tree_amr                              

  Grid array { size = [100]; parallel = ["mpi"] }

  # Only physics method is hydro using ppm

  Method ppm {
      gamma     = 1.4;
      courant   = 0.5;
      diffusion = false
  }

  # Define initial conditions

  Initial {
     pressure   = 1.0;
     density    = 1.0;
     velocity_x = 0
  }

  # Define boundary conditions

  Boundary { 
     density_lower := @@@;
     density = [ density_lower, x == 0];
     density = [ "reflecting",  x == 1];
  
     @@@ decode ExternalBoundary::SetWavePoolBoundary code above @@@
 
  }

  # Define stopping criteria

  Stopping {
     time  = 1.0;
     cycle = 10000
  }

  # Output

  Output data {
     file_name = ["wave_pool-t=%3.1f.data", t];
     time_interval = 0.1;
     # time_absolute = [0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0];
  }

}}}

