%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%    This LaTeX source was automatically generated by outlinebeamer.pl     %
%                                                                          %
%   Remember that most changes should be made to the outline source file   %
% changes to this file will be overwritten when the file gets regenerated  %
%                                                                          %
%                  outlinebeamer - Outline Beamer Class Presentation Maker %
%                                    http://outlinebeamer.sourceforge.net/ %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\documentclass{beamer}

%
% Introduction: ENZO-P / Cello
%    
%   * Goals
%     - petascalable
%       - fault-tolerant
%       - dynamic parallel task creation / migration
%     - improved software development
%       - requirements, design, implement, test
%       - partition code into ``physics'' and ``computer science''
%   * Cello
%     - Framework for extreme AMR
%     - supports hyperbolic and elliptic methods
%     - Hierarchical parallelism
%       - distributed memory (MPI-1, MPI-2, UPC, charm++)
%       - shared memory (OpenMP, UPC, charm++)
%       - dynamic task generation and 
%     - just the framework, no actual physics routines
%   * Enzo-P
%     - Enzo physics built on Cello AMR framework
%     - 
%
% Comparing Enzo with Enzo-P
%
%   * Compiling
%     - scons not make
%     - unit tests integrated with code build
%   * Source code
%     - organized into "component" subdirectories
%       - e.g. Mesh, Field, Particles, Parameters
%       - Enzo-P code goes in User component
%   * Problem definition
%     - Enzo:  problem definition in code ("problem_type") and parameter file
%     - Enzo-P problem definition in parameter file
%     - requires much more flexible parameter files
%       - hierarchical organization
%       - more types 
%       - more difficult to implement
%       - flex for lexical analysis, bison for parsing
%         - generates C-code, which is thoroughly tested
%   * AMR
%     - Enzo: "patch-based" structured AMR (SAMR)
%     - Enzo-P: modified "octree-based" AMR
%       - similar to e.g. Flash, but with several (currently proprietary) enhancements
%       - improved scalability:
%         - fully distributed metadata
%         - only data transfer is between adjacent grid patches
%           - no parent-child
%       - improved performance
%         - patches subdivided into "blocks" (cache-friendly)
%         - unigrid is single AMR patch of blocks
%         - a timestep on a block is a single parallel task
%       - enhancements for "wide" problems (large regions at same level)
%         - Basic octree with fixed-sized blocks refines too much
%           - Flash patch count proportional to refinement area * $8^{level}$
%           - Enzo-P patch count proportional to refinement-change area $8^{level}$
%           - [figure]
%           - Enzo patch count good, but smaller patches at finer levels
%       - enhancements for "deep" problems (many refinement levels)
%         - octree refinment not "targeted": single point involves entire domain
%         - we will allow refinement by 4 and possibly 8
%            - still maintain smooth level jumps by 2 everywhere
%         - will address integer index range issues
%         - will address floating point positional precision issues
%      
%   * Enzo-P limitations
%     - cubical domains
%       - may be able to bypass
%         - use subset of domain
%         - set boundary conditions at internal positions
%         - need to refine along physical boundary for accuracy
%         - mask-out unused patches / blocks
%
% User-perspective
%
%   * Parameter files
%     * parameters organized into "groups" and "subgroups"
%     * parameter types much more flexible than Enzo
%     * Enzo-P developers can trivially add new parameters:
%        parameters->set_current_group("Physics");
%        bool physics_on = parameters->("enable_physics",true);
%   * Parameter file example: Implosion problem
%   * Parameter file data types
%
%     - integer
%     - scalar
%     - logical
%     - string
%     - list
%     - scalar expression, 
%     - logical expression
%
%   * 
% Fields
%
%   * 
% Initial Unigrid Release "Soon"
%
%   * Pre-release
%     - unigrid only
%     - PPM hydro only
%     - MPI only
%     - Why use it?
%       - flexible parameter files
%       - hopefully faster and more scalable
%         - adjustable field ordering, alignment, padding
%         - multiple data blocks per process (more cache friendly)
%         - treats unigrid as unigrid, not as AMR
%       - I need feedback
%
% Roadmap
%
%   + gravity (FFT(Harkness) or multigrid)
%   + PPML (with Kritsuk and Ustyugov
%   + AMR (after development and paper)
%   
%
% Information
%
%   * Public website
%   * Developer website (LCA has accounts) (make developer accounts)
%
% Feedback desired
%
% * Fundamental missing functionality?
% * Parameters?
% * Is framework sufficient for Enzo-P development?
% 
% Features
%
%   parameters: hierarchical
%   parameters: expressive data types
%   parameters: easy to add new parameters: just use [API example]
%   parameters: compare parameter files with Enzo [implosion]
%   AMR:        totally new AMR approach: generalization of octrees--rationale
%   AMR:        additional level of refinement: patches + blocks
%   AMR:        new [currently proprietary] enhancement for "large, shallow" AMR
%   AMR:        new [currently proprietary] enhancement for "deep, targeted" AMR
%   AMR:        no level jumps, symmetric refinement for symmetric problems
%   AMR:        ghost zones optionally allocated only when needed
%   AMR:        octree node memory footprint is light: 3 pointers (24 bytes) per patch
%   AMR:        optional fully distributed AMR hierarchy
%   Field:      data layout controlable from parameter file: ordering, padding, alignment, [interleaving]
%   Field:      default precision specified in parameter file, can be overridden for individual fields (may require promoting before passing to computational kernals)
%   Field:      ghost zone depth  specified in parameter file, can be overridden for individual fields
%   Field:      minimum/maximum values for fields optionally specified in input file, including action (warning, error, reduce time step, alternate method)
%   
%   Field:      fields explicitly specified in parameter file
%   Field:      field groups specified in parameter file (e.g. "color", etc.)
%   Output:     Currently HDF5 and IFrit files supported
%   Output:     Different output 'types', restart, data, visualization, analysis, etc.
%
%   Enzo-P:     All Enzo physics code in User component
%   Enzo-P:     Includes methods (block advance, face update), timestep determination, control (ala EvolveLevel)
%   
%   parallel:   hierarchical: distributed-memory, shared-memory [GPU level]
%   parallel:   any level can be parallelized with different parallel technology (MPI,UPC,etc.)
%   parallel:   load balancing approach specified in parameter file, may be user-defined.  Initially space-filling curve, ultimately hierarchical diffusion
%   parallel:   fully distributed data structures (no / fixed global metadata)
%  
%   scalability: Only adjacent block communication--no parent/child communication
%   scalability: Optional fully-distributed hierarchy (local patch + neighboring "ghost" patches)
%   scalability: dynamic task scheduling (a block can advance when it has its boundary data, regardless of level)
%   scalability: "problem" scaling: integer index ranges addressed
%   scalability: "problem" scaling: positional floating point precision problems addressed
%   scalability: allow local timestepping: no global synchronization 
%   performance: block sizes can be fixed (or at least quantized, e.g. $4^3$ $8^3$ or $16^3$), reducing memory fragmentation, improving cache utilization
%   performance: AMR enhancements will greatly reduce metadata
%   roadmap:    available now: Fields, Parameters, serial unigrid PPM
%   roadmap:    available imminently: parallel unigrid MPI-[12] PPM, PPML, gravity (FFT or MG)
%   roadmap:    available next: basic AMR (octree), local physics 
%   roadmap:    longer-term: particles, cosmology, enhanced AMR
%   roadmap:    papers: AMR enhancements
%   roadmap:    
%   development: extensive unit tests built into build
%   development: scons instead of make: advantages [disadvanteges]
%   development: currently subversion is sufficient--no branching
%   development: "physics" part separate from parallelism and data structures
%   problem support: Deep: integer range and floating point precision
%   problem support: Deep: "level windows" to reduce memory usage
%   problem support: AMR enhancements for targeted refinement by 4 or 8 ["backfill" to maintain level jumps at most 2]
%   feedback:  parameters
%   feedback:  functionality
%   feedback:  
%   
%   
\documentclass{beamer}

\usetheme{Copenhagen}
\usecolortheme{default}

\newcommand{\Code}[1]{\textsf{#1}}
\newcommand{\cello}{\textsf{Cello}}
\newcommand{\enzo}{\textsf{Enzo}}
\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\us}[1]{\color{blue}{#1}}
\newcommand{\them}[1]{\color{red}{#1}}
\newcommand{\newus}[1]{\color{magenta}{#1}}
\newcommand{\good}{\textcolor{green}{\smiley}}
\newcommand{\bad}{\textcolor{red}{\frownie}}
\newcommand{\colorcode}[1]{\textcolor{blue}{\code{#1}}}
\newcommand{\itemnum}[1]{\item<#1>}

%========================================================================
% UNCOMMENT TO PRINT
%========================================================================

 \newcommand{\enhance}[1]{}
 \newcommand{\enhancebf}[2]{\textbf{#2}}
 \newcommand{\enhanceus}[1]{\color{blue}}
 \newcommand{\enhancenewus}[1]{\color{magenta}}
 \newcommand{\enhancethem}[1]{\color{red}}
\newcommand{\ENHANCE}[1]{
 \temporal<#1>{\color{lightgray}}{\color{black}}{\color{gray}}}

%========================================================================
% UNCOMMENT FOR TALK:
%========================================================================

% \newcommand{\enhance}[1]{\temporal<#1>{\color{lightgray}}{\color{black}}{\color{black}}}
% \newcommand{\enhancebf}[2]{\enhance{#1}\textbf{#2}}
% \newcommand{\enhanceus}[1]{\temporal<#1>{\color{lightgray}}{\color{blue}}{\color{blue}}}
% \newcommand{\enhancenewus}[1]{\temporal<#1>{\color{lightgray}}{\color{magenta}}{\color{magenta}}}
% \newcommand{\enhancethem}[1]{\temporal<#1>{\color{lightgray}}{\color{red}}{\color{red}}}
%\newcommand{\ENHANCE}[1]{
% \temporal<#1>{\color{lightgray}}{\color{black}}{\color{black}}}
%========================================================================


% \def\enhanceus<#1>{%
%  \temporal<#1>{\color{lightgray}}{\color{blue}}{\color{blue}}}
% \def\enhancenewus<#1>{%
%  \temporal<#1>{\color{lightgray}}{\color{magenta}}{\color{magenta}}}
% \def\enhancethem<#1>{%
%  \temporal<#1>{\color{lightgray}}{\color{red}}{\color{red}}}


%\includeonly{array}

\author{James Bordner}
\date{June 28, 2010}

%======================================================================
\begin{document}
\frame{
\centerline{\includegraphics[width=3.5in]{Enzo-P-logo-full-2.png}}
\centerline{Dr.~James Bordner} \ \\
\centerline{San Diego Supercomputer Center}
\centerline{University of California, San Diego} \ \\
\centerline{June 28, 2010} \ \\
}

%========================================================================
% SECTION PAGES [ COMMENT FOR PRINT ]
%========================================================================
\frame{\footnotesize
\tableofcontents}
 \AtBeginSection[]
{
%------------------------------------------------------------------------
  \begin{frame}<beamer>
\footnotesize
   \tableofcontents[currentsection]
  \end{frame}
}
%========================================================================

%========================================================================
\section{Introduction}
%========================================================================

% \include{outline}

%------------------------------------------------------------------------
\subsection{Goals}
%------------------------------------------------------------------------
\include{goals}


%------------------------------------------------------------------------
\subsection{Scope}
%------------------------------------------------------------------------

\include{users}
\include{problems}

%------------------------------------------------------------------------
\subsection{Issues}
%------------------------------------------------------------------------

\include{petascale-issues}

%========================================================================
\section{Software Design}
%========================================================================

%------------------------------------------------------------------------
\subsection{Input files}
%------------------------------------------------------------------------

\include{parameters}
\include{implosion-1}
\include{implosion-2}
\include{implosion-3}

%------------------------------------------------------------------------
\subsection{Software components}
%------------------------------------------------------------------------

\include{components}
% \include{components-control}
% \include{components-middle}
% \include{components-hardware}
% \include{components-interface}
% \include{components-support}

%========================================================================
\section{Data Structures}
%========================================================================

%------------------------------------------------------------------------
\subsection{Related AMR applications}
%------------------------------------------------------------------------

\include{app-chombo}
\include{app-flash}
\include{app-cello}
\include{app-table}

%------------------------------------------------------------------------
\subsection{Cello AMR and Arrays}
%------------------------------------------------------------------------

\include{array-amr}
\include{array}
\include{amr}

%------------------------------------------------------------------------
\subsection{Point-source tree-AMR example}
%------------------------------------------------------------------------

\include{amr-point-source}
%------------------------------------------------------------------------
\subsection{Cosmology tree-AMR example}
%------------------------------------------------------------------------
\include{amr-cosmology}

%========================================================================
\section{Issues and Solutions}
%========================================================================
%\include{ideas}
%------------------------------------------------------------------------
\subsection{Dynamic scheduling}
%------------------------------------------------------------------------
\include{idea-charm}
%------------------------------------------------------------------------
\subsection{Time-stepping}
%------------------------------------------------------------------------
\include{idea-timestepping}
%------------------------------------------------------------------------
\subsection{Particle positions}
%------------------------------------------------------------------------
\include{idea-particle-precision}
%------------------------------------------------------------------------
\subsection{Load balancing}
%------------------------------------------------------------------------
\include{idea-load-balance}
%\include{idea-grid-precision}
%\include{idea-gravity}
%------------------------------------------------------------------------
\subsection{Software resiliency}
%------------------------------------------------------------------------
\include{idea-resiliency}
%------------------------------------------------------------------------
%\subsection{Software quality}
%------------------------------------------------------------------------
%\include{idea-quality}

%========================================================================
\section{Conclusions}
%========================================================================

\include{conclusions}

\end{document}
