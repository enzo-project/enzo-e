%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
\chapter{Components} \label{c:components}
%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

% \centerline{\includegraphics{uml/core-components.1}}


\centerline{\includegraphics[totalheight=3in]{components.eps}}

   This chapter describes the design of \cello\ at the component
   level.  Each component is described, including the component
   interdependencies, interface, and classes.

\begin{description}
%
 \item [Simulation (\S\ref{s:component-simulation}): ]
%
        Description and management of computational astrophysics
        problem or ensemble of problems.  Controls sequencing of and
        interactions between other components such as \code{Parallel},
        \code{Method}, and \code{Field}.
%
 \item [Problem (\S\ref{s:component-problem}): ]
%
        The problem refers to the initial setup of the problem,
        including the domain, boundary and initial conditions.
%
 \item [Region (\S\ref{s:component-region}): ]
%
        A \code{Region} is a portion of space and time.
        \code{Region}s are used whenever problem characteristics, data
        structure behavior, or physics computations vary between
        different spacial or temporal \code{Region}s.  A \code{Region}
        is used to define the entire domain.  \code{Region}s may vary
        in time, for example they may grow, shrink, appear, or
        disappear.
%
 \item [Timestep (\S\ref{s:component-timestep}): ]
%
        \code{Timestep} handles the timestepping of methods to advance
        the problem forward in time.
%
 \item [Method (\S\ref{s:component-method}): ]
%
        Defines how to simulate the physics in the computational
        universe.  A \code{Method} specifies the numerical method to
        use, which \code{Field}s are involved, and any associated
        method-specific parameters.  Sequencing and coupling of
        \code{Method}s is defined in \code{Problem} and implemented in
        \code{Control}.  Analysis and visualization are considered
        \code{Method}s as well.
%
 \item [Physics (\S\ref{s:component-physics}): ]
%
        Defines what physics to simulate in the computational
        universe.  Used to define which physics processes are enabled,
        such as self-gravity, hydrodynamics, cosmological expansion,
        etc.  Also defines any parameters associated with the physics
        of the problem being solved, such as cosmological parameters
        and the gravitational constant.
%
 \item [Field (\S\ref{s:component-field}): ]
%
        A \code{Field} is used to represent a specific continuous
        scalar or vector field.  The actual \code{Field} is
        represented either using adaptive mesh refinement via
        \code{Amr}, or as a collection of particles using
        \code{Particles}.  Includes \code{Units} to define the problem
        units, as well as scaling amount to improve numerics, and
        scaling quantization to avoid precision loss.
%
 \item [Amr (\S\ref{s:component-amr}): ]
%
        The \code{Amr} component includes classes for representing
        multi-resolution data on a hierarchy of grid patches of
        varying spacial and temporal resolutions.  The \code{AMR} data
        structures can have multiple levels of data distribution and
        parallelism.  Uses the \code{Parallel} component for
        controlling the parallel communication, synchronization, and
        load-balancing.
%
 \item [Particles (\S\ref{s:component-particles}): ]
%
        The \code{Particles} component serves to represent multi-level
        parallel distribution of sets of various types of particle
        data.  Uses the \code{Parallel} component for controlling the
        parallel communication, synchronization, distribution, and
        load-balancing of \code{Particles}.
%
 \item [Array (\S\ref{s:component-array}): ]
%
        The \code{Array} component is used for representing a single
        array of up to $3$ dimensions.  The \code{Array} may include
        options for MPI-, OMP-, UPC-, or GPU-based parallelism, as
        well as options for controlling memory layout to improve cache
        performance.
%
 \item [Parallel (\S\ref{s:component-parallel}): ]
%
        The \code{Parallel} component is used to specify and control
        the levels of parallelizion (simulations, patches, and
        subblocks), type of parallelization (shared- or
        distributed-memory), and mechanism for controling the
        parallelism (MPI-1 2-sided, MPI-2 1-sided, OpenMP, UPC).
        Lower-level parameters provide detailed control of buffering,
        blocking or nonblocking, patch-to-processor mapping,
        subblock-to-thread mapping, etc.
%
 \item [Disk (\S\ref{s:component-disk}): ]
%
        The \code{Disk} component controls what, when, and how to
        input and output large-scale data to long-term permanent
        storage, primarily \code{Fields} (represented as
        \code{Particles} or \code{Arrays}).
%
 \item [Memory (\S\ref{s:component-memory}): ]
%
        The \code{Memory} component controls dynamic memory
        allocation, and includes features for monitoring memory usage,
        improving performance, and verifying correctness.
%
 \item [Error (\S\ref{s:component-error}): ]
%
        The \code{Error} package is used to detect errors, evaluate
        them, and decide what to do about them.  This includes
        maintaining restart data dumps, and may involve shutting down
        a processor or node and rebalancing the data, etc.
%
 \item [Parameters (\S\ref{s:component-parameters}): ]
%
        The \code{Parameters} component
        reads in a parameter file or files, and provides the
        application access to parameter values.
%
%
 \item [Performance (\S\ref{s:component-performance}): ]
%
        The \code{Performance} component monitors performance such as
        memory usage, computation amount, parallel communication,
        parallel load balancing, disk storage, etc., and provides
        access functions to be called from other components.
%
 \item [Monitor (\S\ref{s:component-monitor}): ]
%
        The \code{Monitor} component controls what and when to output
        user-readable summary information about the running
        application, such as status summary, progress, warnings,
        errors, and performance information.
%
 \item [Portal (\S\ref{s:component-portal}): ]
%
        The \code{Portal} component controls the interaction of the
        application with external applications, for both obtaining
        information about a running simulation, and controling it.
\end{description}

%-----------------------------------------------------------------------

\input{component-simulation}
\input{component-problem}
\input{component-region}
\input{component-timestep}
\input{component-method}
\input{component-physics}
\input{component-field}
\input{component-amr}
\input{component-particles}
\input{component-array}
\input{component-parallel}
\input{component-disk}
\input{component-memory}
\input{component-error}
\input{component-parameters}
\input{component-performance}
\input{component-monitor}
\input{component-portal}

% \input{component-control}
% \input{component-parameters}
% \input{      component-units}
% \input{      component-domain}
% \input{      component-boundary}
% \input{      component-initial}
% \input{      component-matter}
% \input{   component-analysis}
% \input{   component-data}
% \input{   component-performance}
