%0       1         2         3         4         5         6         7         8
%2345678901234567890123456789012345678901234567890123456789012345678901234567890

\documentclass[10pt]{article}

\include{include}

%==================================================================
% Margins and spacing
%==================================================================

\begin{document}

%=======================================================================
\TITLE{\hypre\ SAMR Linear Solver}
      {James Bordner}
      {in preparation}
%=======================================================================

\tableofcontents
%======================================================================
\section{Overview}
%======================================================================

   \hypresolve\ will be used as a testbed for experimenting with the
   parallel solution of linear systems arising from self-gravity and
   radiation transfer algorithms defined on distributed SAMR
   hierarchies.  The purpose of this document is to specify the
   requirements, describe the design and implementation, and present
   test results for \hypresolve.

   We break the problem into two components: problem generation
   (\code{hypre-init}), and problem solution (\code{hypre-solve}).
   \code{hypre-init} takes as input parameters describing the problem
   characteristics in general terms, such as bounds on grid sizes,
   number of processors, description of how to distribute point
   masses, etc.  The output is a file of parameters that specify the
   exact problem to solve, including grid locations, sizes, levels,
   point mass locations, etc.  This file output by \code{hypre-init}
   is subsequently input by \code{hypre-solve}, together with
   solver-specific parameters.  A distributed linear system is
   assembled and solved using \hypre, and the solution, performance
   information, solver efficiency information, etc., are output.

%    \note{top-level diagram: problem description $\Rightarrow$
%   \code{hypre-init} $\Rightarrow$ problem specification $\Rightarrow$
%   \code{hypre-solve} $\Rightarrow$ problem results}

%======================================================================
\section{Roadmap and Milestones}
%======================================================================

\begin{enumerate}
\item \todo\ Unigrid Poisson
\item \todo\ AMR Poisson with $R=2$
\item \todo\ AMR Poisson with $R=2^k$
\item \todo\ AMR Poisson with arbitrary $R$
\item \todo\ General $7$-point stencil
\end{enumerate}

%======================================================================
\section{Components}
%======================================================================

%-----------------------------------------------------------------------
\subsection{\code{hypre-init}} \label{ss:hypre-init}
%-----------------------------------------------------------------------

\subsubsection{Input}  \label{sss:hypre-init-input}

\begin{tabbing}
xxxxx\=xxxxxxxxxxxxxxxxxxxxxxxx\=\kill
\> \todo\ \code{dimension} \> \code{\textit{int dimension}} \\
\> \todo\ \code{particle\_position\_clumpiness}  \\
\> \todo\ \code{particle\_mass\_clumpiness} \\
\> \todo\ \code{particle\_mass\_average} \\
\> \todo\ \code{sphere} \> \code{\textit{Scalar mass}, \textit{Scalar radius}, \textit{Scalar*3 center}} \\
\> \todo\  \code{domain\_extents} \\
\> \todo\  \code{processor\_grid} \\
\> \todo\ \code{discret} \> \code{\textit{int type}} \\
\> \todo\  \code{levels} \\
\> \todo\ \code{solver} \> \code{\{"fac"\} method}
\end{tabbing}

\subsubsection{Output} \label{sss:hypre-init-output}

See \S\ref{sss:hypre-solve-input}.


% \textbf{Input}
% 
% \begin{tabbing}
% xxxxx\=xxx\=\kill\\ 
% \> \todo \>  Maximum number of point masses \\
% \> \todo \>  Description of probability distribution of point masses \\
% \> \todo \>  Number of spheres \\
% \> \todo \>  Positions of spheres \\
% \> \todo \>  Masses of spheres \\
% \> \todo \>  Extents of the domain \\
%  \\
% \> \todo \>  Lower bound on grid sizes \\
% \> \todo \>  Upper bound on grid sizes \\
% \> \todo \>  Upper bound on number of grids \\
%  \\
% \> \todo \>  AMR hierarchy depth \\
% \> \todo \>  AMR Refinement factor (2,3,4) \\
% \end{tabbing}
% 
% \textbf{Output}
% 
%  depth of refinement point layer around point masses
%  depth of refinement point layer around spheres


%-----------------------------------------------------------------------
\subsection{\code{hypre-solve}}  \label{ss:hypre-solve}
%-----------------------------------------------------------------------

\subsubsection{Input} \label{sss:hypre-solve-input}

The following table lists the input parameters to \code{hypre-solve}.

\begin{tabbing}
xxxxx\=xxxxxxxxxxx\=\kill
\> \done\ \code{dimension} \> \code{int} \icode{dimension} \\
\> \todo\ \code{domain} \> \code{Scalar*3} \icode{vertex-lower} \\
\> \> \code{Scalar*3} \icode{vertex-upper} \\
\> \done\ \code{sphere} \> \code{Scalar} \icode{mass} \\
\> \> \code{Scalar} \icode{radius} \\
\> \> \code{Scalar*3} \icode{center} \\
\> \done\ \code{point} \> \code{Scalar} \icode{mass} \\
\> \> \code{Scalar*3} \icode{location} \\
\> \done\ \code{grid} \> \code{int} \icode{id} \\
\> \> \code{int} \icode{parent-id} \\
\> \> \code{int} \icode{processor} \\
\> \> \code{Scalar} \icode{vertex-lower} \\
\> \> \code{Scalar} \icode{vertex-upper} \\
\> \> \code{int*3} \icode{index-lower} \\
\> \> \code{int*3} \icode{zone-count} \\
\> \todo\ \code{discret} \> \code{\icode{int} \icode{type}} \\
\> \todo\ \code{solver} \> \code{\{"fac"\}} \icode{method}
\end{tabbing}


\subsubsection{Output}  \label{sss:hypre-solve-output}

\begin{tabbing}
xxxxx\=xxxxxxxxxxxxxx\=\kill
\> \todo\ \code{flops-balance} \>    \textit{Load balance efficiency with respect to flops}\\
\> \todo\ \code{flops-proc-avg} \> \textit{Average flop counts over processors} \\
\> \todo\ \code{flops-proc-max} \> \textit{Maximum flop counts over processors} \\
\> \todo\ \code{flops-total} \> \textit{Number of floating point operations} \\
\> \todo\ \code{mem-balance} \>    \textit{Load balance efficiency with respect to memory}\\
\> \todo\ \code{mem-proc-avg} \> \textit{Average memory usage over processors} \\
\> \todo\ \code{mem-proc-max} \>    \textit{Maximum memory usage over processors} \\
\> \todo\ \code{mem-total} \> \textit{Amount of memory used} \\
\> \todo\ \code{procs-total} \> \textit{Number of processors} \\
\> \todo\ \code{time-total} \>  \textit{Time to solution}
\end{tabbing}


%======================================================================
\section{Using \hypre}
%======================================================================

This section describes the sequence of calls in \hypre\ used for
setting up a linear system on an AMR hierarchy, and then solving it.

\begin{enumerate}
\item Initialize \hypre\ grids (\S\ref{ss:hypre-grids}) (\code{Hypre::init\_hierarchy()})
\item Initialize \hypre\ stencil (\S\ref{ss:hypre-stencil}) (\code{Hypre::init\_stencil()})
\item Initialize \hypre\ graph (\S\ref{ss:hypre-graph}) (\code{Hypre::init\_graph()})
\item Initialize \hypre\ matrix (\S\ref{ss:hypre-matrix}) (\code{Hypre::init\_matrix()})
\item Initialize \hypre\ vectors (\S\ref{ss:hypre-vectors}) (\code{Hypre::init\_rhs()})
\item Initialize \hypre\ solvers (\S\ref{ss:hypre-solvers}) (\code{Hypre::init\_solver()})
\item Apply \hypre\ solver (\code{Hypre::solve()})
\end{enumerate}

%-----------------------------------------------------------------------
\subsection{Initialize \hypre\ grids} \label{ss:hypre-grids}
%-----------------------------------------------------------------------

For each grid patch it owns, each processor creates a \hypre\ grid
object defining the grid's extents and variables.  

\begin{itemize}
\item \code{HYPRE\_SStructGridCreate()}
\item \code{HYPRE\_SStructGridSetExtents()}
\item \code{HYPRE\_SStructGridSetVariables()}
\item \code{HYPRE\_SStructGridAssemble()}
\end{itemize}

Neighboring grids do not need to be set using \hypre's
\code{HYPRE\_SStructGridSetNeighborBox()} function, since grids within an AMR
level are in the same \hypre\ ``part''.  However, since \hypresolve\
needs to know which zones in a grid are adjacent to neighboring grid
zones for setting up the inter-level grid elements, \hypresolve\ has
its own version of \code{HYPRE\_SStructGridSetNeighborBox()}.

%-----------------------------------------------------------------------
\subsection{Initialize \hypre\ stencil} \label{ss:hypre-stencil}
%-----------------------------------------------------------------------

  Create the stencil object which defines the matrix nonzeros within each grid.

\begin{itemize}
\item \code{HYPRE\_SStructStencilCreate()}
\item \code{HYPRE\_SStructStencilSetEntry()}
\end{itemize}

%-----------------------------------------------------------------------
\subsection{Initialize \hypre\ graph} \label{ss:hypre-graph}
%-----------------------------------------------------------------------

 Each processor creates a graph containing the nonzero structure of
 the matrix.

\begin{itemize}
\item \code{HYPRE\_SStructGraphCreate()}
\item \code{HYPRE\_SStructGraphSetStencil()}
\item \code{HYPRE\_SStructGraphAddEntries()}
\item \code{HYPRE\_SStructGraphAssemble()}
\end{itemize}

%-----------------------------------------------------------------------
\subsection{Initialize \hypre\ matrix} \label{ss:hypre-matrix}
%-----------------------------------------------------------------------

\begin{itemize}
\item \code{HYPRE\_SStructMatrixCreate()}
\item \code{HYPRE\_SStructMatrixInitialize()}
\item \code{HYPRE\_SStructMatrixSetBoxValues()}
\item \code{HYPRE\_SStructMatrixSetValues()}
\item \code{HYPRE\_SStructMatrixAssemble()}
\end{itemize}

%-----------------------------------------------------------------------
\subsection{Initialize \hypre\ vectors} \label{ss:hypre-vectors}
%-----------------------------------------------------------------------

\begin{itemize}
\item \code{HYPRE\_SStructVectorCreate()}
\item \code{HYPRE\_SStructVectorInitialize()}
\item \code{HYPRE\_SStructVectorSetBoxValues()}
\item \code{HYPRE\_SStructVectorAssemble()}
\end{itemize}

%-----------------------------------------------------------------------
\subsection{Initialize \hypre\ solvers} \label{ss:hypre-solvers}
%-----------------------------------------------------------------------

%=======================================================================
\section{Design} \label{s:design}
%=======================================================================

%-----------------------------------------------------------------------
\section{Classes} \label{ss:classes}
%-----------------------------------------------------------------------

%-----------------------------------------------------------------------
\subsection{AMR classes}

The AMR hierarchy is represented using the trio of classes
\code{hierarchy}, \code{Level}, and \code{Grid}.  A \code{Grid} is a
box in space, and is decomposed into \code{GridLocal} and
\code{GridRemote} classes (see \S\ref{sss:class-grid}).  Each
\code{GridLocal} object has some number of \code{Field} objects
associated with them (see \S\ref{sss:class-field}), though the
\code{GridLocal} objects themselves do not store field data
themselves.  A \code{Level} class is also either a ``structured''
\code{LevelStruct} or an ``unstructured'' \code{LevelUnstruct}.
Structured levels are composed of a regular array of \code{Grid}s, and
is typically used for unigrid calculations or the root level of an AMR
calculation.  Unstructured levels are typically used for non-root
levels of an AMR calulation.

\begin{center}
\epsfig{file=uml/hierarchy.1,width=0.75in}
\end{center}

%-----------------------------------------------------------------------
\subsubsection{\code{Hierarchy} class} \label{sss:class-hierarchy}

\begin{center}
\epsfig{file=uml/class-hierarchy.1,width=1.5in}
\end{center}

%-----------------------------------------------------------------------
\subsubsection{\code{Level} class} \label{sss:class-level}

\begin{center}
\epsfig{file=uml/class-level.1,width=1.5in}
\end{center}

%-----------------------------------------------------------------------
\subsubsection{\code{Grid} class} \label{sss:class-grid}

\begin{center}
\epsfig{file=uml/grid.1,     width=2.00in}
\end{center}


\begin{center}
\epsfig{file=uml/class-grid.1,width=2.5in}
\end{center}

%-----------------------------------------------------------------------
\subsection{Problem classes}

\code{Problem}, \code{Sphere}, and \code{Point}

%-----------------------------------------------------------------------
\subsubsection{\code{Problem} class} \label{sss:class-problem}

\begin{center}
\epsfig{file=uml/class-problem.1,width=2.0in}
\end{center}

%-----------------------------------------------------------------------
\subsubsection{\code{Sphere} class} \label{sss:class-sphere}

\begin{center}
\epsfig{file=uml/class-sphere.1,width=1.0in}
\end{center}

%-----------------------------------------------------------------------
\subsection{Discretization classes}

%-----------------------------------------------------------------------
\subsubsection{\code{Discret} class} \label{sss:class-discret}

\begin{center}
\epsfig{file=uml/class-discret.1,width=2.5in}
\end{center}

%-----------------------------------------------------------------------
\subsubsection{\code{Hypre} class}  \label{sss:class-hypre}

\begin{center}
\epsfig{file=uml/class-hypre.1,width=2.0in}
\end{center}

%-----------------------------------------------------------------------
\subsubsection{\code{Mpi} class} \label{sss:class-mpi}

\begin{center}
\epsfig{file=uml/class-mpi.1,width=1.5in}
\end{center}

%-----------------------------------------------------------------------
\subsubsection{\code{Point} class} \label{sss:class-point}

\begin{center}
\epsfig{file=uml/class-point.1,width=1.0in}
\end{center}

%-----------------------------------------------------------------------
\subsubsection{\code{Field} class} \label{sss:class-field}

\begin{center}
\epsfig{file=uml/field.1,     width=0.75in}
\end{center}

%-----------------------------------------------------------------------
\subsubsection{\code{Array} class} \label{sss:class-array}

%=======================================================================
\section{Discretization} \label{s:discretization}
%=======================================================================

\newcommand{\indvar}{r}
 \newcommand{\uc}{u(\indvar)}

 \newcommand{\uxp}{u(\indvar+h_x)}
 \newcommand{\uxm}{u(\indvar-h_x)}
 \newcommand{\uxph}{u(\indvar+\frac{h_x}{2})}
 \newcommand{\uxmh}{u(\indvar-\frac{h_x}{2})}

 \newcommand{\uyp}{u(\indvar+h_y)}
 \newcommand{\uym}{u(\indvar-h_y)}
 \newcommand{\uyph}{u(\indvar+\frac{h_y}{2})}
 \newcommand{\uymh}{u(\indvar-\frac{h_y}{2})}

 \newcommand{\uzp}{u(\indvar+h_z)}
 \newcommand{\uzm}{u(\indvar-h_z)}
 \newcommand{\uzph}{u(\indvar+\frac{h_z}{2})}
 \newcommand{\uzmh}{u(\indvar-\frac{h_z}{2})}

 \newcommand{\ac}{a(\indvar)}
 \newcommand{\axph}{a(\indvar+\frac{h_x}{2})}
 \newcommand{\axmh}{a(\indvar-\frac{h_x}{2})}
 \newcommand{\ayph}{a(\indvar+\frac{h_y}{2})}
 \newcommand{\aymh}{a(\indvar-\frac{h_y}{2})}
 \newcommand{\azph}{a(\indvar+\frac{h_z}{2})}
 \newcommand{\azmh}{a(\indvar-\frac{h_z}{2})}

 \newcommand{\alc}{\alpha_{0}}
 \newcommand{\alxp}{\alpha_{x}}
 \newcommand{\alxm}{\alpha_{\bar{x}}}
 \newcommand{\alyp}{\alpha_{y}}
 \newcommand{\alym}{\alpha_{\bar{y}}}
 \newcommand{\alzp}{\alpha_{z}}
 \newcommand{\alzm}{\alpha_{\bar{z}}}

 \newcommand{\Uc}{U_{0}}
 \newcommand{\Uxp}{U_{x}}
 \newcommand{\Uxm}{U_{\bar{x}}}
 \newcommand{\Uyp}{U_{y}}
 \newcommand{\Uym}{U_{\bar{y}}}
 \newcommand{\Uzp}{U_{z}}
 \newcommand{\Uzm}{U_{\bar{z}}}

We wish to discretize $- \nabla\cdot(\ac \nabla \uc) = \bar{\rho}$
on a structured AMR hierarchy with arbitrary refinement factor $r$
between successive levels.  We consider discretizing within levels in
\S\ref{ss:discret-within-levels}, and between
levels in \S\ref{ss:discret-between-levels}.

%-----------------------------------------------------------------------
\subsection{Discretization within levels} \label{ss:discret-within-levels}
%-----------------------------------------------------------------------

We wish to discretize $- \nabla\cdot(\ac \nabla \uc) = \bar{\rho}$
within a uniform $3$D grid level.  We assume that grid spacing
$h_{x}$, $h_{y}$, and $h_{z}$ within a level is uniform.  The unknowns
$u(r)$, (``$\Box$'' in the figure) are located at cell centers, and
the known coefficients $a(r)$ (``$\circ$'' in the figure) are
evaluated at cell faces.  The black unknown depends on grey unknowns
and grey coefficients.  To simplify visualization, the figure
represents the $2$D analog of the $3$D problem.  For the special case
of the Poisson equation, $a(r)\equiv 1$.

\begin{center}
\begin{minipage}{1.5in}
\epsfig{file=fig/stencil.eps,width=1.5in}
\end{minipage} 
\end{center}


 \begin{eqnarray*}
 \nabla\cdot(\ac \nabla \uc) & = & D_x (\ac D_x \uc) + D_y (\ac D_y \uc) + D_z (\ac D_z \uc) \\
 & \approx & \frac{\delta_{h_x}}{h_x} (\ac \frac{\delta_{h_x}}{h_x} \uc) + 
             \frac{\delta_{h_y}}{h_y} (\ac \frac{\delta_{h_y}}{h_y} \uc) + 
             \frac{\delta_{h_z}}{h_z} (\ac \frac{\delta_{h_z}}{h_z} \uc) \\
 & \approx & \alzm\Uzm +  \alym\Uym +  \alxm\Uxm 
  +  \alc\Uc 
  +  \alxp\Uxp +  \alyp\Uyp +  \alzp\Uzp,
 \end{eqnarray*}
where

\[\alxm  \equiv  \frac{1}{h_x^2} \axmh,
 \alym  \equiv  \frac{1}{h_y^2} \aymh, 
 \alzm  \equiv  \frac{1}{h_z^2} \azmh \]
 \[\alxp  \equiv  \frac{1}{h_x^2} \axph, 
 \alyp  \equiv  \frac{1}{h_y^2} \ayph,
 \alzp  \equiv  \frac{1}{h_z^2} \azph \]
 \[\alc   \equiv  - [\alxm + \alym + \alzm + \alxp + \alyp + \alzp]. \]

If we assume 1) $a(x)\equiv 1$, 2) $h\equiv h_x = h_y = h_z$, and 3)
we scale $\nabla\cdot(\ac \nabla \uc) = \bar{\rho}$ by multiplying
each side by $C_h \equiv (-h^2)$, then we have

\[\alxm  \equiv  -1,
 \alym  \equiv  -1,
 \alzm  \equiv  -1,
 \alxp  \equiv  -1,
 \alyp  \equiv  -1,
 \alzp  \equiv  -1,
 \alc   \equiv  6 \]

%-----------------------------------------------------------------------
\subsection{Discretization between levels} \label{ss:discret-between-levels}
%-----------------------------------------------------------------------

All inter-level discretizations involve zones along a patch boundary;
however, not all zones along a patch boundary are involved in
inter-level discretization.  Since we will be discussing zones along a
patch boundary, we define a zone to be a ``\textit{face-zone}'' if it
lies along the external boundary of its containing grid patch.

\begin{center}
\begin{minipage}{4in}
\epsfig{file=fig/neighbor.eps,width=4in}
\end{minipage}
\end{center}

\begin{description}
\item[boundary: ] The face-zone is adjacent to the domain boundary
\item[neighbor: ] The face-zone is adjacent to a zone in a neighboring patch.  The neighboring patch and containing patch may not necessarily have the same parent.
\item[coarse: ] The face-zone is adjacent to a zone in the containing patch's parent, or
a zone in a neighbor of the containing patch's parent.
\item[fine: ] The face-zone is adjacent to zones in a child of a neighbor of the containing patch's parent.
\item[covered: ] The face-zone is covered by face zones in a finer level.
\end{description}

By ``neighbor'' above, we imply ``in the same refinement level''.

Assumptions we make include the following:

\begin{itemize}
\item Adjacent zones must not span more than one level
\item Boundary face-zones are in the coarsest grid level
\item if one face-zone along a particular face is a boundary face-zone, then
all face-zones in that particular face are boundary face-zones
\end{itemize}

\subsubsection{categorization of face-zones}

Defining characteristics of face-zone categories include the following:

\begin{description}
\item [boundary: ] the face-zone is adjacent to the domain boundary
\item [covered: ] the grid containing the face-zone has a child grid that covers the zone
\item [fine: ] the face-zone is not covered, the containing grid has a neighboring grid adjacent to the face-zone, and the paired face-zone in the neigboring grid is covered
\item [neighbor: ] the face-zone is not covered, the containing grid has a neighboring grid adjacent to the face-zone, and the paired face-zone in the neighboring grid is not covered
\item [coarse: ] the face-zone is not covered, and the containing grid does not have a neighboring grid adjacent to the face-zone
\end{description}
\begin{tabular}{l|cccc}
category & boundary & covered & adjacent grid & covered neighbor \\ \hline
boundary & true &  \\
covered  &        & true \\
fine     & false & false & true & true \\
neighbor & false & false  & true& false \\
coarse   & false & false  & false \\
\end{tabular}

Categorizing requires four processes:

\begin{itemize}
\item[1.] Label boundary face-zones
\begin{tabbing}
xxx\=xxx\=xxx\=xxx\=xxx\=xxx\=xxx\=xxxxxxxxxxxxxxxxxxx\=\kill
\> \textbf{for} \code{grid} in \code{level-0} \\
\>\> \textbf{for} \code{face} in \code{grid} \\
\>\>\> \textbf{if} \code{face} along boundary \\
\>\>\>\> \textbf{for} \code{face-zone} in \code{face} \\
\>\>\>\>\> \code{label (face-zone,boundary)}
\end{tabbing}
\item[2.] Label covered face-zones
\begin{tabbing}
xxx\=xxx\=xxx\=xxx\=xxx\=xxx\=xxx\=xxxxxxxxxxxxxxxxxxx\=\kill
\> \textbf{for} \code{level} in \code{hierarchy} (fine to coarse) \\
\>\> \textbf{for} \code{grid} in \code{level} \\
\>\>\> \code{sub-face = intersection(grid-face,parent(grid)-face)} \\
\>\>\>\> \textbf{for} \code{face-zone} in \code{sub-face} of \code{parent(grid)}\\
\>\>\>\>\>     \code{label (face-zone,covered)} \\
\>\>\>\> \textbf{for} \code{face-zone} in \code{sub-face} of \code{adjacent(parent(grid))}\\
\>\>\>\>\>     \textbf{if} \code{face-zone not covered} \\
\>\>\>\>\>\> \code{label (face-zone,adjacent-covered)}
\end{tabbing}
\item[3-4.] Label fine and neighbor face-zones
\begin{tabbing}
xxx\=xxx\=xxx\=xxx\=xxx\=xxx\=xxx\=xxxxxxxxxxxxxxxxxxx\=\kill
\> \textbf{for} \code{level} in \code{hierarchy} (fine to coarse) \\
\>\> \textbf{for} \code{grid} in \code{level} \\
\>\>\> \code{sub-face = intersection(grid-face,parent(grid)-face)} \\
\>\>\>\> \textbf{for} \code{face-zone} in \code{sub-face} of \code{parent(grid)}\\
\>\>\>\>\> \textbf{if} \code{face-zone is adjacent-covered} \\
\>\>\>\>\>\> \code{label (face-zone,fine)} \\
\>\>\>\>\> \textbf{else} \\
\>\>\>\>\>\> \code{label (face-zone,neighbor)} \\
\end{tabbing}
\item[5.] Label coarse face-zones
\begin{tabbing}
xxx\=xxx\=xxx\=xxx\=xxx\=xxx\=xxx\=xxxxxxxxxxxxxxxxxxx\=\kill
\> \textbf{for} \code{face-zone} in \code{hierarchy} \\
\>\> \textbf{if} \code{face-zone} not labeled \\
\>\>\>        \code{label (face-zone,coarse)}
\end{tabbing}
\end{itemize}

% \begin{tabbing}
% xxx\=xxx\=xxx\=xxx\=xxx\=xxx\=xxx\=xxxxxxxxxxxxxxxxxxx\=\kill
% \> \textbf{for} \code{level} in \code{hierarchy} \textit{// (finest first)}\\
% \>\> \textbf{for} \code{grid} in \code{level} \\
% \\
% \>\>\> \textit{// *** Find boundary face-zones ***} \\
% \\
% \>\>\> \textbf{for} \code{face} in \code{grid} \\
% \>\>\>\>   \textbf{if} \code{face} is along \code{domain boundary} \\
% \>\>\>\>\>   \textbf{for} \code{face-zone} in \code{face} \\
% \>\>\>\>\>\>     \code{label (face-zone,boundary)} \\
% \\
% \>\>\> \textit{// *** Find covered face-zones ***} \\
% \\
% \>\>\> \textbf{for} \code{child} of \code{grid} \\
% \>\>\>\> \code{sub-face = intersection(child-face,grid-face)} \\
% \>\>\>\> \textbf{for} \code{face-zone} in \code{sub-face} \\
% \>\>\>\>\>     \code{label (face-zone,covered)} \\
% \\
% \>\>\> \textit{// *** Find fine face-zones ***} \\
% \\
% \>\>\> \textit{// *** Find neighbor face-zones ***} \\
% \\
% \>\>\> \textbf{for} \code{neighbor} of \code{grid} \textit {// (include non-siblings)}\\
% \>\>\>\> \code{sub-face = intersection(neighbor-face,grid-face)} \\
% \>\>\>\> \textbf{for} \code{face-zone} in \code{sub-face} \\
% \>\>\>\>\>     \code{label face-zone as boundary} \\
% \\
% \>\>\> \textit{// *** Find coarse face-zones ***} \\
% \end{tabbing}



% \begin{tabbing}
% xxx\=xxx\=xxx\=xxx\=xxx\=xxx\=xxx\=xxxxxxxxxxxxxxxxxxx\=\kill
% \> \textbf{for} \code{level} in \code{hierarchy} \textit{// (finest first)}\\
% \>\> \textbf{for} \code{grid} in \code{level} \\
% \\
% \>\>\> \textit{// *** Find boundary face-zones ***} \\
% \\
% \>\>\> \textbf{for} \code{face} in \code{grid} \\
% \>\>\>\>   \textbf{if} \code{face} is along \code{domain boundary} \\
% \>\>\>\>\>   \textbf{for} \code{face-zone} in \code{face} \\
% \>\>\>\>\>\>     \code{label (face-zone,boundary)} \\
% \\
% \>\>\> \textit{// *** Find covered face-zones ***} \\
% \\
% \>\>\> \textbf{for} \code{child} of \code{grid} \\
% \>\>\>\> \code{sub-face = intersection(child-face,grid-face)} \\
% \>\>\>\> \textbf{for} \code{face-zone} in \code{sub-face} \\
% \>\>\>\>\>     \code{label (face-zone,covered)} \\
% \\
% \>\>\> \textit{// *** Find fine face-zones ***} \\
% \\
% \>\>\> \textit{// *** Find neighbor face-zones ***} \\
% \\
% \>\>\> \textbf{for} \code{neighbor} of \code{grid} \textit {// (include non-siblings)}\\
% \>\>\>\> \code{sub-face = intersection(neighbor-face,grid-face)} \\
% \>\>\>\> \textbf{for} \code{face-zone} in \code{sub-face} \\
% \>\>\>\>\>     \code{label face-zone as boundary} \\
% \\
% \>\>\> \textit{// *** Find coarse face-zones ***} \\
% \end{tabbing}

\subsubsection{discretization along face-zones}

By default, zone connections are defined using stencil connections defined
using \hypre\ stencil values, which we derive in \S\ref{ss:discret-within-levels}.
Below, we derive modifications for each category of face-zone.

\textbf{boundary face-zones}.



\textbf{covered face-zones}.


\textbf{fine face-zones}.

\textbf{neighbor face-zones}.  Neighbor face-zones are handled by \hypre\ stencil


\textbf{coarse face-zones}.



\begin{center}
\begin{minipage}{1.25in}
\epsfig{file=fig/stencil0.eps,width=1.25in}
\end{minipage} \ \ \ 
\begin{minipage}{1.25in}
\epsfig{file=fig/stencil1.eps,width=1.25in}
\end{minipage} \ \ \ 
\begin{minipage}{1.25in}
\epsfig{file=fig/stencil2.eps,width=1.25in}
\end{minipage}
\end{center}



\begin{center}
\begin{minipage}{2in}
\epsfig{file=fig/discret6.eps,width=2.0in}
\end{minipage}$\Rightarrow$
\begin{minipage}{2in}
\epsfig{file=fig/discret5.eps,width=2.0in}
\end{minipage}$\Rightarrow$
\begin{minipage}{2in}
\epsfig{file=fig/discret4.eps,width=2.0in}
\end{minipage} \\
\begin{minipage}{4.5in}
\hfill $\Downarrow$
\end{minipage} \\
\begin{minipage}{2in}
\epsfig{file=fig/discret3.eps,width=2.0in}
\end{minipage}$\Rightarrow$
\begin{minipage}{2in}
\epsfig{file=fig/discret2.eps,width=2.0in}
\end{minipage}$\Rightarrow$
\begin{minipage}{2in}
\epsfig{file=fig/discret1.eps,width=2.0in}
\end{minipage}
\end{center}

\begin{center}
\begin{minipage}{6.0in}
\epsfig{file=fig/discret-step-1.eps,width=6.0in}
\end{minipage}
\end{center}

Grid patches are controlled using
\begin{itemize}
\item \code{HYPRE\_SStructGridCreate()}
\item \code{HYPRE\_SStructGridSetExtents()}
\item \code{HYPRE\_SStructGridSetVariables()}
\item \code{HYPRE\_SStructGridSetNeighborBox()}
\item \code{HYPRE\_SStructGridAssemble()}
\item \code{HYPRE\_SStructGridSetNumGhost()}
\item \code{HYPRE\_SStructGridDestroy()}
\end{itemize}

Stencils are controlled using
\begin{itemize}
\item \code{HYPRE\_SStructStencilCreate()}
\item \code{HYPRE\_SStructStencilSetEntry()}
\item \code{HYPRE\_SStructStencilDestroy()}
\end{itemize}

Graphs are controlled using
\begin{itemize}
\item \code{HYPRE\_SStructGraphCreate()}
\item \code{HYPRE\_SStructGraphSetStencil()}
\item \code{HYPRE\_SStructGraphAddEntry()}
\item \code{HYPRE\_SStructGraphSetObjectType()}
\item \code{HYPRE\_SStructGraphAssemble()}
\item \code{HYPRE\_SStructGraphDestroy()}
\end{itemize}

Matrices are controlled using
\begin{itemize}
\item \code{HYPRE\_SStructMatrixCreate()}
\item \code{HYPRE\_SStructMatrixInitialize()}
\item \code{HYPRE\_SStructMatrixGetObject()}
\item \code{HYPRE\_SStructMatrixSetObjectType()}
\item \code{HYPRE\_SStructMatrixSetValues()}
\item \code{HYPRE\_SStructMatrixAddToValues()}
\item \code{HYPRE\_SStructMatrixSetBoxValues()}
\item \code{HYPRE\_SStructMatrixAddToBoxValues()}
\item \code{HYPRE\_SStructMatrixDestroy()}
\item \code{HYPRE\_SStructMatrixPrint()}
\end{itemize}

Vectors are controlled using:
\begin{itemize}
\item \code{HYPRE\_SStructVectorCreate()}
\item \code{HYPRE\_SStructVectorInitialize()}
\item \code{HYPRE\_SStructVectorGetObject()}
\item \code{HYPRE\_SStructVectorSetObjectType()}
\item \code{HYPRE\_SStructVectorSetValues()}
\item \code{HYPRE\_SStructVectorAddToValues()}
\item \code{HYPRE\_SStructVectorSetBoxValues()}
\item \code{HYPRE\_SStructVectorAddToBoxValues()}
\item \code{HYPRE\_SStructVectorDestroy()}
\item \code{HYPRE\_SStructVectorPrint()}
\end{itemize}




Types of matrix elements for a given unknown:

\begin{tabular}{ll}
\textcolor{green}{internal} & \code{HYPRE\_SStructStencilSetEntry()} \\
\textcolor{green}{overlapped internal} & \code{HYPRE\_SStructStencil} \\
\textcolor{red}{neighbor} & \code{HYPRE\_SStructGridSetNeighborBox()}\\
\textcolor{blue}{boundary} & \code{HYPRE\_SStructGraphAddEntries()}\\
\textcolor{magenta}{fine-coarse parent} & \code{HYPRE\_SStructGraphAddEntries()}\\
\textcolor{cyan}{coarse-fine child} & \code{HYPRE\_SStructGraphAddEntries()}\\
\textcolor{brown}{fine-coarse parent--neighbor} & \code{HYPRE\_SStructGraphAddEntries()}\\
\textcolor{yellow}{coarse-fine neighbor--child} & \code{HYPRE\_SStructGraphAddEntries()}\\
\end{tabular}

%=======================================================================
\section{Test Results} \label{s:results}
%=======================================================================

\begin{tabular}{l|l} \\
\textbf{Term} & \textbf{Term description} \\ \hline
$N_0$ & Root-grid zones per processor \\
$n_0$ & Root-grid zones-per-axis  per processor \\
$N_P$ & Number of processors \\
$N_G$ & Number of grids \\
$N_L$ & Number of levels \\
$N_Z$ & Number of zones \\
\end{tabular}

\begin{tabular}{l|ccccc} \\
Problem & $N_0$ & $N_P$ & $N_G$ & $N_L$ & $N_Z$ \\ \hline
serial-unigrid       & $8^3:\sqrt{2}:128^3$ & & & \\
parallel-unigrid     & $16^3:2\ldots 128^3$ & & & \\
Simple serial AMR    & $32^3\ldots 128^3$ & & & \\
Simple parallel AMR  & $32^3\ldots 128^3$ & & & \\
General serial AMR   & $32^3\ldots 128^3$ & & & \\
General parallel AMR & $32^3\ldots 128^3$ & & & \\
Large AMR            & $32^3\ldots 128^3$ & & & \\
\end{tabular}

\begin{tabular}{l|l} \\
\textbf{Plot name} & \textbf{Plot description} \\ \hline
\code{procs-mem} & Processor count versus memory (bytes) \\
\code{procs-mem-zone} & Processor count versus memory per zone (bytes) \\
\code{procs-time} & Processor count versus time (seconds) \\
\code{procs-time-zone} & Processor count versus time per zone (seconds) \\
\code{size-mem-zone} &  Problem size (number of zones) versus memory per zone (bytes) \\
\code{size-mem-zone} &  Problem size ($n$) versus memory (bytes) \\
\code{size-time-zone} &  Problem size (number of zones) versus time per zone (seconds) \\
\code{size-time-zone} &  Problem size ($n$) versus time (seconds) \\
\end{tabular}

\EndDOCUMENT

\end{document}
%==================================================================

