# Problem: 2D Implosion problem
#  Author: James Bordner (jobordner@ucsd.edu)
#    Date: 2010-04-06
#

   Cello {
      code_version_major = 0;
      code_version_minor = 3;
      code_version_patch = 2;
   }

   Domain { 
      extent = [0.0, 0.3, 0.0, 0.3] 
   } 

   Mesh { 
      root_size      = [400,400];
      max_level      = 0;
      backfill       = false;
      refine         = 2;
      balanced       = true;
      backfill       = true;
      coalesce       = true;
      min_patch_size = 4;
      max_patch_size = 32;
   }

   Field {
 
      courant   = 0.8;
      padding   = 0;
      alignment = 8;
    
      names = ["density", "velocity_x", "velocity_y", "total_energy"];

      groups = ["computed"];

      pressure { 

         # issue an error if the pressure falls below 1.0e-6 anywhere

         min_value  = 1.0e-6;
         min_action = "warning";

         # pressure is computed not evolved

         groups = ["computed"];
      };

      density  { 

         # If a method calls the density field "rho" instead of "density"

         alias = ["rho"];

         # issue a warning if the density falls below 1.0e-6 anywhere

         min_value = 1.0e-6; 
         min_action = "warning";

         # for fun, use double precision for density even if default is single

         precision = "double"
      };

      # Velocity is face-centered not cell-centered

      velocity_x { centering = [false, true];  };
      velocity_y { centering = [true, false];  }
   }

   Method {

      # list of methods to apply and in what order
 
      sequence = ["ppm"];

      ppm {

         # method-specific parameters.  Note this is Enzo-P not Cello 

         diffusion   = false;
         flattening  = false;
         steepening  = true;
         dual_energy = false;
     }
   }

   Physics {
      gamma = 1.4;
   }

   Initial {

      # equivalent to density(x,y) = (x + y < 0.15) ? 0.125 : 1.0

      density  = [ 0.125, x + y < 0.15, 1.0 ];  

      pressure = [ 0.14,  x + y < 0.15, 1.0 ];

      # (@@@ can parameter types be a scalar or a list?)

      velocity_x = 0.0;
      velocity_y = 0.0;
   }

   Boundary { type = "reflecting" }

   Stopping {
      time  = 2.5;
      cycle = 20000;
      # redshift
   }

   Output { 
      data {
        type = "data";
        delta_time = 0.5 ;  # dt? time? 
 
      };
      restart {
        type = "restart";
        # default restart parameters(?)
      }
        
   }
 