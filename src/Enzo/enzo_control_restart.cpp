// See LICENSE_CELLO file for license and copyright information

/// @file     enzo_control_restart.cpp
/// @author   James Bordner (jobordner@ucsd.edu)
/// @date     2022-03-10
/// @brief    Enzo-E portion of restart
/// @ingroup  Enzo
///
/// This file controls restarting from files generated by a previous call
/// to EnzoMethodCheck

//--------------------------------------------------

#include "enzo.hpp"

#include "charm_simulation.hpp"
#include "charm_mesh.hpp"
#include "main.hpp"

// #define TRACE_BLOCK
// #define TRACE_HDF5
// #define PRINT_FIELD_RESTART
// # define TRACE_SYNC

//--------------------------------------------------
#ifdef TRACE_SYNC
#   undef TRACE_SYNC
#   define TRACE_SYNC(SYNC,MSG)                                         \
  CkPrintf ("TRACE_SYNC %p %s %d/%d\n", \
            (void *)(&SYNC), std::string(MSG).c_str(),SYNC.value(),SYNC.stop()); \
  fflush(stdout);
#else
#   define TRACE_SYNC(SYNC,MSG) /* ... */
#endif
//--------------------------------------------------
#ifdef PRINT_FIELD_RESTART
#   undef PRINT_FIELD_RESTART

#   define PRINT_FIELD_RESTART(MSG,FIELD,DATA)                                  \
  {                                                                     \
    Field field = DATA->field();                                        \
    int mx,my,mz;                                                       \
    int gx,gy,gz;                                                       \
    int index_field = field.field_id(FIELD);                            \
    field.dimensions(index_field,&mx,&my,&mz);                          \
    field.ghost_depth(index_field,&gx,&gy,&gz);                         \
    enzo_float * value = (enzo_float *)field.values(FIELD);             \
    enzo_float min=1e30;                                                \
    enzo_float max=-1e30;                                               \
    enzo_float sum=0;                                                   \
    for (int iz=gz; iz<mz-gz; iz++) {                                   \
      for (int iy=gy; iy<my-gy; iy++) {                                 \
        for (int ix=gx; ix<mx-gx; ix++) {                               \
          const int i=ix+mx*(iy+my*iz);                                 \
          min=std::min(min,value[i]);                                   \
          max=std::max(max,value[i]);                                   \
          sum+=value[i];                                                \
        }                                                               \
      }                                                                 \
    }                                                                   \
    CkPrintf ("PRINT_FIELD_RESTART %s %s  %g %g %g\n",MSG,FIELD,min,max,sum/((mx-2*gx)*(my-2*gy)*(mz-2*gz))); \
    fflush(stdout);                                                     \
  }
#else
#   define PRINT_FIELD_RESTART(MSG,FIELD,DATA) /* ... */
#endif
//--------------------------------------------------
#ifdef TRACE_BLOCK
#   undef TRACE_BLOCK
#   define TRACE_RESTART(MSG) \
  CkPrintf ("%d TRACE_RESTART %s\n",CkMyPe(),std::string(MSG).c_str()); \
  fflush(stdout);
#   define TRACE_BLOCK(MSG,BLOCK)                                    \
  CkPrintf ("%d TRACE_RESTART %s %s\n",CkMyPe(),BLOCK->name().c_str(), \
            std::string(MSG).c_str());                         \
  fflush(stdout);
#else
#   define TRACE_RESTART(MSG)  /* ... */
#   define TRACE_BLOCK(MSG,BLOCK) /* ... */
#endif


//----------------------------------------------------------------------

void Block::restart_enter_()
{
  TRACE_BLOCK("restart_enter_",this);
  const std::string restart_dir  = cello::config()->initial_restart_dir;
  if (index_.is_root()) {
    proxy_simulation[0].p_restart_enter(restart_dir);
  }
}

//----------------------------------------------------------------------

void Simulation::p_restart_enter (std::string name_dir)
{
  // [ Called on root ip only ]

  restart_directory_ = name_dir;

  // Open and read the checkpoint file_list file
  restart_stream_file_list_ = file_open_file_list_(restart_directory_);
  restart_stream_file_list_ >> restart_num_files_;

  // set synchronization
  sync_restart_done_.set_stop(restart_num_files_);

  // Create new empty IoEnzoReader chare array and distribute to other processing elements
  CProxy_MappingIo io_map  = CProxy_MappingIo::ckNew(restart_num_files_);

  CkArrayOptions opts(restart_num_files_);
  opts.setMap(io_map);
  // create array
  proxy_io_enzo_reader = CProxy_IoEnzoReader::ckNew(opts);
  // distribute array proxy to other simulation objects
  proxy_enzo_simulation.p_set_io_reader(proxy_io_enzo_reader);

}

//----------------------------------------------------------------------

void EnzoSimulation::p_set_io_reader(CProxy_IoEnzoReader io_enzo_reader)
{
  TRACE_RESTART("EnzoSimulation::p_set_io_reader()");
  proxy_io_enzo_reader = io_enzo_reader;
  CkCallback callback(CkIndex_Simulation::r_restart_start(NULL),0,
                      proxy_simulation);
  contribute(callback);
}

//----------------------------------------------------------------------

void Simulation::r_restart_start (CkReductionMsg * msg)
{
  delete msg;
  // [ Called on root ip only ]

  TRACE_SYNC(sync_restart_done_,"sync_restart_done_ set_stop");
  // Insert an IoEnzoReader element for each file
  for (int i=0; i<restart_num_files_; i++) {
    std::string name_file;
    restart_stream_file_list_ >> name_file;
    // Create ith io_reader to read name_file
    proxy_io_enzo_reader[i].p_initialize(restart_directory_,name_file);
  }
}

//----------------------------------------------------------------------

void IoEnzoReader::p_initialize
(std::string name_dir, std::string name_file) throw()
{
  name_dir_ = name_dir;
  name_file_ = name_file;
  stream_block_list_ = open_block_list_(name_dir, name_file);

  // open the HDF5 file
#ifdef TRACE_HDF5
  CkPrintf ("%d TRACE_HDF5 file_open[%d] (%s,%s)\n",
            CkNumPes(),thisIndex,name_dir.c_str(),name_file.c_str());
#endif
  file_ = file_open_(name_dir,name_file);

  sync_blocks_.reset();
  TRACE_SYNC(sync_blocks_,"sync_blocks_ reset");

  // Read global attributes
  file_read_hierarchy_();

  int level_block;
  std::string block_name;
  while (read_block_list_(block_name,level_block)) {

    // Increment block counter so know when to alert pe=0 when done
    sync_blocks_.inc_stop(1);
    TRACE_SYNC(sync_blocks_,"sync_blocks_ inc_stop(1)");

    // For each Block in the file, read the block data and create the
    // new Block
    EnzoMsgCheck * msg_check = new EnzoMsgCheck;
    file_read_block_ (msg_check, block_name);

    Index index;
    int v3[3];
    msg_check->io_block_->index(v3);
    index.set_values(v3);
    const int level = index.level();
    msg_check->index_file_ = thisIndex;
    if (level <= 0) {

      // Block exists--send its data
      enzo::block_array()[index].p_restart_set_data(msg_check);

    } else {

      // Block doesn't exist: create it and send its data
      enzo::factory()->create_block_check
        ( msg_check, enzo::block_array(),index );

      // Also tell parent that it has children (surprise!)
      Index index_parent = index.index_parent(cello::config()->mesh_min_level);
    }
  }

  // close the HDF5 file
#ifdef TRACE_HDF5
  CkPrintf ("%d TRACE_HDF5 data_close[%d]\n", CkNumPes(),thisIndex);
#endif
  file_->data_close();
#ifdef TRACE_HDF5
  CkPrintf ("%d TRACE_HDF5 file_close[%d]\n", CkNumPes(),thisIndex);
#endif
  file_->file_close();
  delete file_;

  close_block_list_();

}

//----------------------------------------------------------------------

void EnzoBlock::p_restart_set_data(EnzoMsgCheck * msg_check)
{ restart_set_data_ (msg_check); }

void EnzoBlock::restart_set_data_(EnzoMsgCheck * msg_check)
{
  TRACE_BLOCK("EnzoBlock::restart_set_data()",this);
  const int index_file = msg_check->index_file_;
  msg_check->update(this);
  PRINT_FIELD_RESTART("recv","density",data());
  delete msg_check;
  proxy_io_enzo_reader[index_file].p_block_ready(name());
}

//----------------------------------------------------------------------

void IoEnzoReader::p_block_ready(std::string block_name)
{ block_ready_(block_name); }

void IoEnzoReader::block_ready_(std::string block_name)
{
  TRACE_RESTART("EnzoSimulation::[p_]block_ready_()");
  TRACE_SYNC(sync_blocks_,"next");
  if (sync_blocks_.next()) {
    proxy_enzo_simulation[0].p_restart_done();
  }
}
//----------------------------------------------------------------------

void EnzoSimulation::p_restart_done()
{
  TRACE_RESTART("EnzoSimulation::p_restart_done()");
  TRACE_SYNC(sync_restart_done_,"sync_restart_done_ next");
  if (sync_restart_done_.next()) {
    enzo::block_array().p_restart_done();
  }
}

void EnzoBlock::p_restart_done()
{
  TRACE_BLOCK("EnzoBlock::p_restart_done()",this);
  adapt_exit_();
}

//======================================================================

std::ifstream Simulation::file_open_file_list_(std::string name_dir)
{
  std::string name_file = name_dir + "/check.file_list";

  std::ifstream stream_file_list (name_file);

  ASSERT1("Simulation::file_copen_file_list_",
          "Cannot open hierarchy file %s for writing",
          name_file.c_str(),stream_file_list);

  return stream_file_list;
}

//----------------------------------------------------------------------

std::ifstream IoEnzoReader::open_block_list_
(std::string name_dir, std::string name_file)
{
  std::string name_file_full = name_dir + "/" + name_file + ".block_list";

  std::ifstream stream_block_list (name_file_full);

  ASSERT1("Simulation::create_block_list_",
          "Cannot open block_list file %s for reading",
          name_file_full.c_str(),stream_block_list);

  return stream_block_list;
}

//----------------------------------------------------------------------

void IoEnzoReader::file_read_hierarchy_()
{
  // Simulation data
  IoSimulation io_simulation = (cello::simulation());
  for (size_t i=0; i<io_simulation.meta_count(); i++) {

    void * buffer;
    std::string name;
    int type_scalar;
    int nx,ny,nz;

    // Get object's ith metadata
    io_simulation.meta_value(i,& buffer, &name, &type_scalar, &nx,&ny,&nz);

    // Read object's ith metadata
#ifdef TRACE_HDF5
    CkPrintf ("%d TRACE_HDF5 [simulation] file_read_meta[%d] %s\n", CkNumPes(),thisIndex,name.c_str());
#endif
    file_->file_read_meta(buffer,name.c_str(),&type_scalar,&nx,&ny,&nz);
  }

  io_simulation.save_to(cello::simulation());

  // Hierarchy data
  IoHierarchy io_hierarchy = (cello::hierarchy());
  for (size_t i=0; i<io_hierarchy.meta_count(); i++) {

    void * buffer;
    std::string name;
    int type_scalar;
    int nx,ny,nz;

    // Get object's ith metadata
    io_hierarchy.meta_value(i,& buffer, &name, &type_scalar, &nx,&ny,&nz);

    // Read object's ith metadata
#ifdef TRACE_HDF5
    CkPrintf ("%d TRACE_HDF5 [hierarchy] file_read_meta[%d] %s\n", CkNumPes(),thisIndex,name.c_str());
#endif
    file_->file_read_meta(buffer,name.c_str(),&type_scalar,&nx,&ny,&nz);
  }
  io_hierarchy.save_to(cello::hierarchy());
}

//----------------------------------------------------------------------

void IoEnzoReader::file_read_block_
(EnzoMsgCheck * msg_check,
 std::string    name_block)
{
  // Open HDF5 group for the block
  std::string group_name = "/" + name_block;
#ifdef TRACE_HDF5
    CkPrintf ("%d TRACE_HDF5 group_chdir[%d] %s\n",
              CkNumPes(),thisIndex,group_name.c_str());
#endif
  file_->group_chdir(group_name);
#ifdef TRACE_HDF5
    CkPrintf ("%d TRACE_HDF5 group_open[%d]\n",
              CkNumPes(),thisIndex);
#endif
  file_->group_open();

  // Read the Block's attributes
  IoBlock * io_block = enzo::factory()->create_io_block();
  msg_check->set_io_block(io_block);
  read_meta_(file_, io_block, "group");

  DataMsg * data_msg = new DataMsg;
  msg_check->data_msg_ = data_msg;

  // Create and allocate the data object
  int nx,ny,nz;
  int root_blocks[3];
  int root_size[3];
  double xm,ym,zm;
  double xp,yp,zp;
  Hierarchy * hierarchy = cello::hierarchy();
  hierarchy->root_blocks(root_blocks,root_blocks+1,root_blocks+2);
  hierarchy->root_size(root_size,root_size+1,root_size+2);
  hierarchy->lower(&xm,&ym,&zm);
  hierarchy->upper(&xp,&yp,&zp);
  nx=root_size[0]/root_blocks[0];
  ny=root_size[1]/root_blocks[1];
  nz=root_size[2]/root_blocks[2];

  int num_field_blocks = 1;
  FieldDescr * field_descr = cello::field_descr();
  ParticleDescr * particle_descr = cello::particle_descr();

  Data * data = new Data
    (nx, ny, nz, num_field_blocks, xm,xp, ym,yp, zm,zp,
     field_descr, particle_descr);

  data->allocate();

  // Loop through fields and read them in

  const int num_fields = field_descr->num_permanent();
  Field field = data->field();

  if (num_fields > 0) {
    // If any fields, add them to DataMsg
    Refresh * refresh = new Refresh;
    refresh->add_all_data();
    FieldFace  * field_face = new FieldFace(cello::rank());

    field_face -> set_refresh_type (refresh_same);
    field_face -> set_child (0,0,0);
    field_face -> set_face (0,0,0);
    field_face -> set_ghost(true,true,true);
    field_face -> set_refresh(refresh,true);

    data_msg -> set_field_face (field_face,false);
    data_msg -> set_field_data (data->field_data(),false);
  }
  for (int i_f=0; i_f<num_fields; i_f++) {

    const std::string field_name = field_descr->field_name(i_f);
    int index_field = field_descr->field_id(field_name);

    const std::string dataset_name = std::string("field_") + field_name;
    int m4[4];
    int type_data = type_unknown;
#ifdef TRACE_HDF5
    CkPrintf ("%d TRACE_HDF5 data_open[%d] %s\n",
              CkNumPes(),thisIndex,dataset_name.c_str());
#endif
    file_->data_open (dataset_name, &type_data,
                      m4,m4+1,m4+2,m4+3);
    int mx,my,mz;
    int gx,gy,gz;

    field.dimensions(index_field,&mx,&my,&mz);
    field.ghost_depth(index_field,&gx,&gy,&gz);

    double lower[3];
    double upper[3];
    io_block->lower(lower);
    io_block->upper(upper);
    char * buffer = field.values(field_name);

    read_dataset_
      (file_, buffer, type_data, mx,my,mz,m4);

    PRINT_FIELD_RESTART("send",field_name.c_str(),data);
#ifdef TRACE_HDF5
    CkPrintf ("%d TRACE_HDF5 data_close[%d]\n",
              CkNumPes(),thisIndex);
#endif
    file_->data_close();

  }

  // Read in particle data

  Particle particle = data->particle();

  // for each particle type
  const int num_types = particle_descr->num_types();
  if (num_types > 0) {
    // If any fields, add them to DataMsg
    data_msg -> set_particle_data (particle.particle_data(),true);
  }
  for (int it=0; it<num_types; it++) {

    const std::string particle_name = particle_descr->type_name(it);
    // for each attribute of the particle type
    const int na = particle_descr->num_attributes(it);
    for (int ia=0; ia<na; ia++) {
      const std::string attribute_name = particle_descr->attribute_name(it,ia);

      const std::string dataset_name =
        std::string("particle_") + particle_name + "_" + attribute_name;
      int m4[4];
      int type_data = type_unknown;
#ifdef TRACE_HDF5
    CkPrintf ("%d TRACE_HDF5 data_open[%d] %s\n",
              CkNumPes(),thisIndex,dataset_name.c_str());
#endif
      file_->data_open (dataset_name, &type_data,
                        m4,m4+1,m4+2,m4+3);

      const int np = m4[0];

      // allocate particles at start once count is known
      if (ia==0) {
        particle.insert_particles(it,np);
      }

      // read particle attribute into single array first...
      union {
        char * buffer;
        float * buffer_single;
        double * buffer_double;
      };

#ifdef TRACE_HDF5
    CkPrintf ("%d TRACE_HDF5 allocate_buffer[%d] %d\n",
              CkNumPes(),thisIndex,np);
#endif
      buffer = file_->allocate_buffer(np,type_data);

      int nx=m4[0];
      int ny=m4[1];
      int nz=m4[2];
      read_dataset_(file_, buffer, type_data, nx,ny,nz,m4);

      // ...then copy to particle batches

      if (type_data == type_single) {
        copy_buffer_to_particle_attribute_
          (buffer_single, particle, it, ia, np);
      } else if (type_data == type_double) {
        copy_buffer_to_particle_attribute_
          (buffer_double, particle, it, ia, np);
      }
    }
  }
#ifdef TRACE_HDF5
    CkPrintf ("%d TRACE_HDF5 group_close[%d]\n",
              CkNumPes(),thisIndex);
#endif
  file_->group_close();
}

//----------------------------------------------------------------------

template <class T>
void IoEnzoReader::copy_buffer_to_particle_attribute_
(T * buffer, Particle particle, int it, int ia, int np)
{
  for (int ip=0; ip<np; ip++) {
    int ib,io;
    particle.index(ip,&ib,&io);
    T * batch = (T *) particle.attribute_array(it,ia,ib);
    batch[io] = buffer[ip];
  }
}

//----------------------------------------------------------------------

void IoEnzoReader::read_meta_
( FileHdf5 * file, Io * io, std::string type_meta )
{
  for (size_t i=0; i<io->meta_count(); i++) {

    void * buffer;
    std::string name;
    int type_scalar;
    int nx,ny,nz;

    // Get object's ith metadata
    io->meta_value(i,& buffer, &name, &type_scalar, &nx,&ny,&nz);

    // Read object's ith metadata
    if ( type_meta == "group" ) {
      file->group_read_meta(buffer,name.c_str(),&type_scalar,&nx,&ny,&nz);
    } else if (type_meta == "file") {
      file->file_read_meta(buffer,name.c_str(),&type_scalar,&nx,&ny,&nz);
    } else {
      ERROR1 ("MethodOutput::read_meta_()",
              "Unknown type_meta \"%s\"",
              type_meta.c_str());
    }
    // Get object's ith metadata

    io->meta_value(i,& buffer, &name, &type_scalar, &nx,&ny,&nz);
  }
}
//----------------------------------------------------------------------

bool IoEnzoReader::read_block_list_(std::string & block_name, int & level)
{
  bool value (stream_block_list_ >> block_name >> level);
  return value;
}

//----------------------------------------------------------------------

void IoEnzoReader::close_block_list_()
{
}

//----------------------------------------------------------------------
FileHdf5 * IoEnzoReader::file_open_
(std::string path_name, std::string file_name)
{
  // Create File
  file_name = file_name + ".h5";
  FileHdf5 * file = new FileHdf5 (path_name, file_name);
  file->file_open();

  return file;
}

//----------------------------------------------------------------------

void IoEnzoReader::read_dataset_
(File * file, char * buffer, int type_data,
 int nx, int ny, int nz,
 int m4[4])
{
  // Read the domain dimensions

  // field size
  int n4[4];
  n4[0] = n4[1] = n4[2] = n4[3] = 1;
  n4[0] = nx;
  n4[1] = ny;
  n4[2] = nz;

  // determine offsets
  int o4[4] = {0,0,0,0};

  // open the dataspace
  file-> data_slice
    (m4[0],m4[1],m4[2],m4[3],
     n4[0],n4[1],n4[2],n4[3],
     o4[0],o4[1],o4[2],o4[3]);

  // create memory space
  file->mem_create (nx,ny,nz,nx,ny,nz,0,0,0);

  file->data_read (buffer);
}
